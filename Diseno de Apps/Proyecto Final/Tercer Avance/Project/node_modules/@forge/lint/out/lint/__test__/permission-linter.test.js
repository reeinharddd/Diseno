"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const permission_linter_1 = require("../permission-linter");
const linter_interface_1 = require("../linter-interface");
const parse_1 = require("../../parse");
const fs_1 = tslib_1.__importDefault(require("fs"));
const xen_test_util_1 = require("@atlassian/xen-test-util");
const cli_shared_1 = require("@forge/cli-shared");
const MOCK_CONFLUENCE_SWAGGER = JSON.parse(fs_1.default.readFileSync(`${__dirname}/mock-confluence-swagger.json`).toString());
const getPermissionLinter = async (manifest) => {
    const permissionLinter = new permission_linter_1.PermissionLinter('default', manifest);
    permissionLinter.getProductPaths = async (key, url) => {
        return url.includes('confluence') ? MOCK_CONFLUENCE_SWAGGER : { paths: {} };
    };
    await permissionLinter.bootstrap();
    return permissionLinter;
};
describe('permission linter', () => {
    let mockAST;
    const mockFile = `const api = { asApp: () => { requestConfluence: (endpoint, opts) => {} } };\nconst response = api.asApp().requestConfluence(\`/wiki/rest/api/content/\${contentId}\`);`;
    const MOCK_HANDLER_NAME = 'testHandler';
    const MOCK_FN_KEY = 'testFnKey';
    const MOCK_FILE_NAME = 'test';
    const VALID_MANIFEST = {
        modules: {
            macro: [
                {
                    key: 'testKey',
                    function: MOCK_FN_KEY,
                    title: 'testTitle'
                }
            ],
            function: [{ key: MOCK_FN_KEY, handler: `${MOCK_FILE_NAME}.${MOCK_HANDLER_NAME}` }]
        }
    };
    beforeAll(async () => {
        mockAST = await parse_1.babelParser(mockFile);
    });
    it('should warn when needed permission is missing', async () => {
        const permissionLinter = await getPermissionLinter(VALID_MANIFEST);
        permissionLinter.getProductPaths = async (key, url) => {
            return url.includes('confluence') ? MOCK_CONFLUENCE_SWAGGER : { paths: {} };
        };
        const results = await permissionLinter.batchExecute([
            {
                ast: mockAST,
                filepath: MOCK_FILE_NAME
            }
        ]);
        expect(results).toMatchObject([
            {
                file: MOCK_FILE_NAME,
                fixer: expect.anything(),
                errors: [],
                warnings: [
                    {
                        class: linter_interface_1.LintClass.Warning,
                        message: 'Confluence endpoint: GET /api/content/{id} requires "read:confluence-content.summary" scope',
                        reference: 'permission-scope-required'
                    }
                ]
            }
        ]);
    });
    it('should not warn when correct permissions are present', async () => {
        const manifestWithPermissions = Object.assign(Object.assign({}, VALID_MANIFEST), { permissions: { scopes: ['read:confluence-content.summary'] } });
        const permissionLinter = await getPermissionLinter(manifestWithPermissions);
        const results = await permissionLinter.batchExecute([
            {
                ast: mockAST,
                filepath: MOCK_FILE_NAME
            }
        ]);
        expect(results).toMatchObject([
            {
                file: MOCK_FILE_NAME,
                fixer: expect.anything(),
                errors: [],
                warnings: []
            }
        ]);
    });
    it('should automatically fix missing permissions', async () => {
        const mockError = {
            class: linter_interface_1.LintClass.Error,
            message: '',
            reference: 'permission-scope-required',
            line: 1,
            column: 1,
            metadata: {
                missingPermission: 'mock-error-permission'
            }
        };
        const mockWarning = Object.assign(Object.assign({}, mockError), { class: linter_interface_1.LintClass.Warning, metadata: {
                missingPermission: 'mock-warning-permission'
            } });
        const mockConfigFile = xen_test_util_1.mock(cli_shared_1.ConfigFile);
        const mockLintFixState = {
            errorsFixed: 0,
            warningsFixed: 0,
            manifest: mockConfigFile
        };
        const fixedState = await permission_linter_1.fixMissingPermissions([mockError], [mockWarning], mockLintFixState);
        expect(mockConfigFile.readConfig).toHaveBeenCalled();
        expect(mockConfigFile.writeToConfigFile).toHaveBeenCalledWith('permissions', {
            scopes: [mockError.metadata.missingPermission, mockWarning.metadata.missingPermission]
        });
        expect(fixedState).toMatchObject({
            errorsFixed: 1,
            warningsFixed: 1,
            manifest: mockConfigFile
        });
    });
    it('should warn when storage permissions are missing for import', async () => {
        const mockFileUsingStorage = `import { storage } from '@forge/api';`;
        const mockASTUsingStorage = await parse_1.babelParser(mockFileUsingStorage);
        const permissionLinter = await getPermissionLinter(VALID_MANIFEST);
        permissionLinter.getProductPaths = async (key, url) => {
            return url.includes('confluence') ? MOCK_CONFLUENCE_SWAGGER : { paths: {} };
        };
        const results = await permissionLinter.batchExecute([
            {
                ast: mockASTUsingStorage,
                filepath: MOCK_FILE_NAME
            }
        ]);
        expect(results).toMatchObject([
            {
                file: MOCK_FILE_NAME,
                fixer: expect.anything(),
                errors: [],
                warnings: [
                    {
                        class: linter_interface_1.LintClass.Warning,
                        message: 'Using the Forge Storage API requires the "storage:app" scope',
                        reference: 'permission-scope-required'
                    }
                ]
            }
        ]);
    });
    it('should warn when fui hook permissions are missing', async () => {
        const mockFileUsingFUIHooks = `import { useSpaceProperty } from '@forge/ui-confluence';`;
        const mockASTUsingFUIHooks = await parse_1.babelParser(mockFileUsingFUIHooks);
        const permissionLinter = await getPermissionLinter(VALID_MANIFEST);
        permissionLinter.getProductPaths = async (key, url) => {
            return url.includes('confluence') ? MOCK_CONFLUENCE_SWAGGER : { paths: {} };
        };
        const results = await permissionLinter.batchExecute([
            {
                ast: mockASTUsingFUIHooks,
                filepath: MOCK_FILE_NAME
            }
        ]);
        const getExpectedRule = (permission) => ({
            class: linter_interface_1.LintClass.Warning,
            message: `Confluence UI hook: "useSpaceProperty" requires the "${permission}" scope`,
            column: 9,
            line: 1,
            reference: 'permission-scope-required'
        });
        expect(results).toMatchObject([
            {
                file: MOCK_FILE_NAME,
                fixer: expect.anything(),
                errors: [],
                warnings: [getExpectedRule('read:confluence-props'), getExpectedRule('write:confluence-props')]
            }
        ]);
    });
    it('should find missing scopes', () => {
        const rule = (scope) => ({
            metadata: {
                missingPermission: scope
            }
        });
        const warnings = [rule('foo'), rule('foo2')];
        const errors = [rule('bar'), rule('bar2')];
        const scopes = permission_linter_1.findMissingScopes(errors, warnings);
        expect(Array.from(scopes)).toEqual(expect.arrayContaining(['foo', 'foo2', 'bar', 'bar2']));
    });
});
