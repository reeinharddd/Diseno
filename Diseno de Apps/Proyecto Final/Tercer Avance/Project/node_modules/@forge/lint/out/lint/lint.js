"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const permission_linter_1 = require("./permission-linter");
const parse_1 = require("../parse");
const cli_shared_1 = require("@forge/cli-shared");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("util");
exports.reportLintResults = (logger, lintResults) => {
    let numErrors = 0, numWarnings = 0;
    let noProblemsFound = true;
    if (lintResults.length) {
        lintResults.forEach((lintResult) => {
            if (lintResult.size()) {
                noProblemsFound = false;
                numErrors += lintResult.errors.length;
                numWarnings += lintResult.warnings.length;
                logger.info(cli_shared_1.Text.lint.filename(path_1.default.resolve(lintResult.file)));
                lintResult.errors.forEach(({ line, column, message, reference }) => {
                    logger.info(cli_shared_1.Text.lint.error(line, column, message, reference));
                });
                lintResult.warnings.forEach(({ line, column, message, reference }) => {
                    logger.info(cli_shared_1.Text.lint.warning(line, column, message, reference));
                });
            }
        });
    }
    if (noProblemsFound) {
        logger.info(cli_shared_1.LogColor.trace(cli_shared_1.Text.lint.noProblems));
        logger.info('');
    }
    else {
        const resultsWithFixers = lintResults.filter((result) => result.hasFixer());
        const numFixableErrors = resultsWithFixers.reduce((count, result) => count + result.errors.length, 0);
        const numFixableWarnings = resultsWithFixers.reduce((count, result) => count + result.warnings.length, 0);
        logger.info(cli_shared_1.Text.lint.summary(numErrors, numWarnings, numFixableErrors, numFixableWarnings));
        process.exitCode = 1;
    }
};
exports.parseSourceFile = async (filepath, parser, readFilePromise = util_1.promisify(fs_1.default.readFile)) => {
    const code = await readFilePromise(filepath, { encoding: 'utf-8' });
    const parseResult = await parser(code, filepath);
    return {
        ast: parseResult,
        filepath
    };
};
exports.lint = async (filesToLint, manifest, environment, parseFunction = exports.parseSourceFile, linters = [new permission_linter_1.PermissionLinter(environment, manifest)]) => {
    const { include, exclude } = await cli_shared_1.listTSConfigIncludeExclude(new cli_shared_1.FileSystemReader());
    const tsInclude = new Set(include);
    const tsExclude = new Set(exclude);
    const lintInputs = (await Promise.all(filesToLint.map(async (filepath) => {
        const ext = path_1.default.extname(filepath);
        if (ext.match(/jsx?$/)) {
            return parseFunction(filepath, parse_1.babelParser);
        }
        else if (ext.match(/tsx?$/)) {
            const relativeFilePath = './' + filepath;
            const tsFileIncluded = tsInclude.has(relativeFilePath);
            const tsFileExcluded = tsExclude.has(relativeFilePath);
            if ((tsFileIncluded && !tsFileExcluded) || (!tsInclude.size && !tsExclude.size)) {
                return parseFunction(filepath, parse_1.tsParser);
            }
        }
        return { ast: null, filepath: '' };
    }))).filter((result) => !!(result === null || result === void 0 ? void 0 : result.ast));
    await Promise.all(linters.map((linter) => linter.bootstrap()));
    const results = await Promise.all(linters.map((linter) => linter.batchExecute(lintInputs))).then(cli_shared_1.flat);
    return results.map((result) => {
        const comparator = (a, b) => a.line === b.line ? a.column - b.column : a.line - b.line;
        result.errors = result.errors.sort(comparator);
        result.warnings = result.warnings.sort(comparator);
        return result;
    });
};
