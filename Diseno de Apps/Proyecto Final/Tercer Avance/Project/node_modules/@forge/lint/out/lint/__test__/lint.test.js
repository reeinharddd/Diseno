"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lint_1 = require("../lint");
const linter_interface_1 = require("../linter-interface");
const parse_1 = require("../../parse");
const cli_shared_1 = require("@forge/cli-shared");
const path_1 = tslib_1.__importDefault(require("path"));
describe('lint', () => {
    describe('reportLintResults', () => {
        const mockLogger = {
            info: jest.fn()
        };
        const mockLintResult = new linter_interface_1.LintResult('mock.file');
        mockLintResult.add({
            class: linter_interface_1.LintClass.Error,
            message: 'this is a mock error',
            reference: 'mock-error',
            line: 0,
            column: 0
        });
        mockLintResult.add({
            class: linter_interface_1.LintClass.Warning,
            message: 'this is a mock warning',
            reference: 'mock-warning',
            line: 0,
            column: 0
        });
        it('should correctly report lint results with an error and a warning', () => {
            const { line: errorLine, column: errorColumn, message: errorMessage, reference: errorReference } = mockLintResult.errors[0];
            const { line: warningLine, column: warningColumn, message: warningMessage, reference: warningReference } = mockLintResult.warnings[0];
            lint_1.reportLintResults(mockLogger, [mockLintResult]);
            const expectedMessages = [
                cli_shared_1.Text.lint.filename(path_1.default.resolve(mockLintResult.file)),
                cli_shared_1.Text.lint.error(errorLine, errorColumn, errorMessage, errorReference),
                cli_shared_1.Text.lint.warning(warningLine, warningColumn, warningMessage, warningReference),
                cli_shared_1.Text.lint.summary(1, 1, 0, 0)
            ];
            expectedMessages.forEach((message) => expect(mockLogger.info).toHaveBeenCalledWith(message));
        });
        it('should correctly report an empty lint result', () => {
            lint_1.reportLintResults(mockLogger, []);
            const expectedMessages = [
                cli_shared_1.Text.lint.filename(path_1.default.resolve(mockLintResult.file)),
                cli_shared_1.LogColor.trace(cli_shared_1.Text.lint.noProblems)
            ];
            expectedMessages.forEach((message) => expect(mockLogger.info).toHaveBeenCalledWith(message));
        });
    });
    describe('parseSourceFile', () => {
        it('should correctly call the parser', async () => {
            const mockReadFilePromise = jest.fn();
            const mockParser = jest.fn().mockResolvedValue(null);
            const mockFilePath = 'mock.jsx';
            const result = await lint_1.parseSourceFile(mockFilePath, mockParser, mockReadFilePromise);
            expect(result).toMatchObject({ ast: null, filepath: mockFilePath });
        });
    });
    describe('lint', () => {
        const mockLinter = {
            bootstrap: jest.fn(),
            batchExecute: jest.fn().mockResolvedValue([])
        };
        const mockParseFunc = jest.fn(async (filepath) => ({ ast: null, filepath }));
        const mockManifest = {};
        const mockEnv = 'DUMMY_ENV';
        it("should call each linter's bootstrap and batchExecute", async () => {
            await lint_1.lint([], mockManifest, mockEnv, mockParseFunc, [mockLinter]);
            expect(mockLinter.bootstrap).toHaveBeenCalled();
            expect(mockLinter.batchExecute).toHaveBeenCalled();
        });
        it('should use the babelParser only on appropriate files', async () => {
            const filesForBabelParsing = ['1.jsx', '1.js'];
            const nonBabelParseFiles = ['1.file', '1.tsx', '1.ts'];
            await lint_1.lint([...filesForBabelParsing, ...nonBabelParseFiles], mockManifest, mockEnv, mockParseFunc, [mockLinter]);
            filesForBabelParsing.forEach((filename) => expect(mockParseFunc).toHaveBeenCalledWith(filename, parse_1.babelParser));
            nonBabelParseFiles.forEach((filename) => expect(mockParseFunc).not.toHaveBeenCalledWith(filename, parse_1.babelParser));
        });
        it('should use the tsParser only on appropriate files', async () => {
            const filesForTSParsing = ['1.tsx', '1.ts'];
            const nonTSParseFiles = ['1.jsx', '1.js', '1.file'];
            await lint_1.lint([...filesForTSParsing, ...nonTSParseFiles], mockManifest, mockEnv, mockParseFunc, [mockLinter]);
            filesForTSParsing.forEach((filename) => expect(mockParseFunc).toHaveBeenCalledWith(filename, parse_1.tsParser));
            nonTSParseFiles.forEach((filename) => expect(mockParseFunc).not.toHaveBeenCalledWith(filename, parse_1.tsParser));
        });
        it("should sort each file's lint results by line number/column", async () => {
            mockLinter.batchExecute.mockResolvedValueOnce([
                {
                    errors: [
                        {
                            line: 1,
                            column: 2
                        },
                        {
                            line: 1,
                            column: 1
                        },
                        {
                            line: 0,
                            column: 1
                        }
                    ],
                    warnings: []
                }
            ]);
            const results = await lint_1.lint([], mockManifest, mockEnv, mockParseFunc, [mockLinter]);
            expect(results).toMatchObject([
                {
                    errors: [
                        {
                            line: 0,
                            column: 1
                        },
                        {
                            line: 1,
                            column: 1
                        },
                        {
                            line: 1,
                            column: 2
                        }
                    ],
                    warnings: []
                }
            ]);
        });
    });
});
