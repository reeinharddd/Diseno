"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const base_linter_1 = tslib_1.__importDefault(require("./base-linter"));
const linter_interface_1 = require("./linter-interface");
const parser_interface_1 = require("../parse/parser-interface");
const cli_shared_1 = require("@forge/cli-shared");
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
exports.ANY_TEXT_REGEX = '\\S*';
const CACHE_KEY = 'PERMISSIONS_LINTER';
const DEV = cli_shared_1.DEFAULT_ENVIRONMENT_OPTION;
const ONE_HOUR_MS = 1000 * 60 * 60;
exports.findMissingScopes = (errors, warnings, state) => {
    const missingPermissions = new Set();
    errors.forEach(({ metadata }) => {
        missingPermissions.add(metadata.missingPermission);
        if (state)
            state.errorsFixed++;
    });
    warnings.forEach(({ metadata }) => {
        missingPermissions.add(metadata.missingPermission);
        if (state)
            state.warningsFixed++;
    });
    return missingPermissions;
};
exports.fixMissingPermissions = async (errors, warnings, state) => {
    var _a, _b;
    const missingPermissions = exports.findMissingScopes(errors, warnings, state);
    const currentPermissions = ((_b = (_a = (await state.manifest.readConfig())) === null || _a === void 0 ? void 0 : _a.permissions) === null || _b === void 0 ? void 0 : _b.scopes) || [];
    currentPermissions.forEach(missingPermissions.add, missingPermissions);
    await state.manifest.writeToConfigFile('permissions', {
        scopes: [...missingPermissions]
    });
    return state;
};
class PermissionLinter extends base_linter_1.default {
    constructor(environment, manifest) {
        super(environment);
        this.manifest = manifest;
    }
    async bootstrap() {
        this.cache = cli_shared_1.CachedConf.getCache(CACHE_KEY);
        const [jira, confluence] = await Promise.all([
            this.getProductPaths(PermissionLinter.JIRA_CACHE_KEY, 'https://developer.atlassian.com/cloud/jira/platform/swagger-v3.v3.json'),
            this.getProductPaths(PermissionLinter.CONFLUENCE_CACHE_KEY, 'https://developer.atlassian.com/cloud/confluence/swagger.v3.json')
        ]);
        this.jira = this.processPaths(jira.paths);
        this.confluence = this.processPaths(confluence.paths);
    }
    async getProductPaths(cacheKey, url) {
        var _a, _b;
        const cached = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.get(cacheKey);
        if (!cached) {
            const response = await node_fetch_1.default(url);
            const jsonBody = await response.json();
            (_b = this.cache) === null || _b === void 0 ? void 0 : _b.set(cacheKey, jsonBody, 12 * ONE_HOUR_MS);
            return jsonBody;
        }
        return cached;
    }
    processPaths(paths) {
        const pathMap = new Map();
        Object.keys(paths).forEach((path) => {
            const key = new RegExp(path.replace(/{(?<={)(.*?)(?=})}/g, exports.ANY_TEXT_REGEX) + '$');
            pathMap.set(key, { originalPath: path, methods: paths[path] });
        });
        return pathMap;
    }
    async execute({ ast, filepath }) {
        if (!this.jira || !this.confluence)
            throw new Error('Bootstrap failed');
        const lintResult = new linter_interface_1.LintResult(filepath, exports.fixMissingPermissions);
        const jiraApiCalls = [];
        const confluenceApiCalls = [];
        const storageApiCalls = [];
        const forgeUIHookCalls = [];
        if ((ast === null || ast === void 0 ? void 0 : ast.type) === parser_interface_1.ParserTypes.Babel) {
            ast.traverse({
                CallExpression: (callExpr) => {
                    if (callExpr.node.callee.type === 'Identifier') {
                        if (callExpr.node.callee.name.match(/request(Jira|Confluence)/)) {
                            const [endpointNode, optionsNode] = callExpr.node.arguments;
                            const apiCallProblem = this.checkProductApiCallArgs(ast.type, endpointNode, optionsNode);
                            if (apiCallProblem) {
                                if (callExpr.node.callee.name === 'requestJira') {
                                    jiraApiCalls.push(apiCallProblem);
                                }
                                else {
                                    confluenceApiCalls.push(apiCallProblem);
                                }
                            }
                        }
                    }
                },
                MemberExpression: (memberExpr) => {
                    var _a, _b, _c;
                    if ((_c = (_b = (_a = memberExpr === null || memberExpr === void 0 ? void 0 : memberExpr.node) === null || _a === void 0 ? void 0 : _a.property) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.match(/request(Jira|Confluence)/)) {
                        const parentCallExpression = memberExpr.parent;
                        const [endpointNode, optionsNode] = parentCallExpression.arguments;
                        const apiCall = this.checkProductApiCallArgs(ast.type, endpointNode, optionsNode);
                        if (apiCall) {
                            if (memberExpr.node.property.name === 'requestJira') {
                                jiraApiCalls.push(apiCall);
                            }
                            else {
                                confluenceApiCalls.push(apiCall);
                            }
                        }
                    }
                },
                ImportDeclaration: (importDecl) => {
                    var _a;
                    (_a = importDecl.node.specifiers) === null || _a === void 0 ? void 0 : _a.filter((specifier) => {
                        if (specifier.type === 'ImportSpecifier' && specifier.local.type === 'Identifier') {
                            if (specifier.local.name === 'storage') {
                                specifier.loc &&
                                    storageApiCalls.push(Object.assign({}, specifier.loc.start));
                            }
                            else if (specifier.local.name.match(/^use(Space|Content|Issue)Property/)) {
                                specifier.loc &&
                                    forgeUIHookCalls.push(Object.assign({ hookName: specifier.local.name }, specifier.loc.start));
                            }
                        }
                    });
                }
            });
        }
        else {
            (ast === null || ast === void 0 ? void 0 : ast.traverse) &&
                ast.traverse({
                    enter: (node, parent) => {
                        switch (node.type) {
                            case typescript_estree_1.AST_NODE_TYPES.CallExpression:
                                if (node.callee.type === 'Identifier' && node.callee.name.match(/request(Jira|Confluence)/)) {
                                    const [endpointNode, optionsNode] = node.arguments;
                                    const apiCallProblem = this.checkProductApiCallArgs(ast.type, endpointNode, optionsNode);
                                    if (apiCallProblem) {
                                        if (node.callee.name === 'requestJira') {
                                            jiraApiCalls.push(apiCallProblem);
                                        }
                                        else {
                                            confluenceApiCalls.push(apiCallProblem);
                                        }
                                    }
                                }
                                break;
                            case typescript_estree_1.AST_NODE_TYPES.MemberExpression:
                                if (node.property.type === typescript_estree_1.AST_NODE_TYPES.Identifier &&
                                    node.property.name.match(/request(Jira|Confluence)/) &&
                                    (parent === null || parent === void 0 ? void 0 : parent.type) === typescript_estree_1.AST_NODE_TYPES.CallExpression) {
                                    const [endpointNode, optionsNode] = parent.arguments;
                                    const apiCall = this.checkProductApiCallArgs(ast.type, endpointNode, optionsNode);
                                    if (apiCall) {
                                        if (node.property.name === 'requestJira') {
                                            jiraApiCalls.push(apiCall);
                                        }
                                        else {
                                            confluenceApiCalls.push(apiCall);
                                        }
                                    }
                                }
                                else if (node.property.type === typescript_estree_1.AST_NODE_TYPES.Identifier &&
                                    !node.property.name.startsWith('on') &&
                                    node.object.type === typescript_estree_1.AST_NODE_TYPES.MemberExpression &&
                                    node.object.object.type === typescript_estree_1.AST_NODE_TYPES.Identifier &&
                                    node.object.object.name === 'api' &&
                                    node.object.property.type === typescript_estree_1.AST_NODE_TYPES.Identifier &&
                                    node.object.property.name === 'store') {
                                    storageApiCalls.push(Object.assign({}, node.loc.start));
                                }
                                break;
                            case typescript_estree_1.AST_NODE_TYPES.ImportDeclaration:
                                node.specifiers.forEach((specifier) => {
                                    if (specifier.type === typescript_estree_1.AST_NODE_TYPES.ImportSpecifier &&
                                        specifier.local.type === typescript_estree_1.AST_NODE_TYPES.Identifier) {
                                        if (specifier.local.name === 'store') {
                                            storageApiCalls.push(Object.assign({}, specifier.loc.start));
                                        }
                                        else if (specifier.local.name.match(/^use(Space|Content|Issue)Property/)) {
                                            forgeUIHookCalls.push(Object.assign({ hookName: specifier.local.name }, specifier.loc.start));
                                        }
                                    }
                                });
                                break;
                        }
                    }
                });
        }
        lintResult.batchAdd(...(await this.addProductApiCallErrors('Jira', jiraApiCalls, this.jira)), ...(await this.addProductApiCallErrors('Confluence', PermissionLinter.processConfluenceURLs(confluenceApiCalls), this.confluence)), ...(await this.addStorageApiCallErrors(storageApiCalls)), ...(await this.addForgeUIHookCallErrors(forgeUIHookCalls)));
        return lintResult;
    }
    static processConfluenceURLs(confluenceApiCalls) {
        return confluenceApiCalls.map((apiCall) => (Object.assign(Object.assign({}, apiCall), { path: apiCall.path.replace(/^.*?\/api/, '/api') })));
    }
    checkProductApiCallArgs(parserType, endpointNode, optionsNode) {
        var _a, _b, _c, _d, _e, _f;
        if (parserType === parser_interface_1.ParserTypes.ESTree) {
            if (endpointNode.loc &&
                [typescript_estree_1.AST_NODE_TYPES.TemplateLiteral, typescript_estree_1.AST_NODE_TYPES.Literal].includes(endpointNode.type)) {
                let endpointString;
                if (endpointNode.type === typescript_estree_1.AST_NODE_TYPES.TemplateLiteral) {
                    const expressions = endpointNode.expressions.map((node) => ({
                        start: node.start,
                        value: exports.ANY_TEXT_REGEX
                    }));
                    const stringInterstitials = endpointNode.quasis.map((node) => ({
                        start: node.start,
                        value: node.value.cooked
                    }));
                    endpointString = [...expressions, ...stringInterstitials]
                        .sort((a, b) => a.start - b.start)
                        .map(({ value }) => value)
                        .join('');
                }
                else {
                    const endpointValue = endpointNode.value;
                    if (typeof endpointValue === 'string') {
                        endpointString = endpointValue;
                    }
                    else {
                        return;
                    }
                }
                const methodProperty = (_b = (_a = optionsNode) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.filter((value) => value.type === typescript_estree_1.AST_NODE_TYPES.Property && value.key.name === 'method')[0];
                const methodValue = ((_c = methodProperty === null || methodProperty === void 0 ? void 0 : methodProperty.value) === null || _c === void 0 ? void 0 : _c.value) || 'GET';
                return {
                    path: endpointString,
                    method: methodValue,
                    line: endpointNode.loc.start.line,
                    column: endpointNode.loc.start.column
                };
            }
        }
        else {
            if (endpointNode.loc && ['TemplateLiteral', 'StringLiteral'].includes(endpointNode.type)) {
                let endpointString;
                if (endpointNode.type === 'TemplateLiteral') {
                    const expressions = endpointNode.expressions.map((node) => ({
                        start: node.start,
                        value: exports.ANY_TEXT_REGEX
                    }));
                    const stringInterstitials = endpointNode.quasis.map((node) => ({
                        start: node.start,
                        value: node.value.cooked
                    }));
                    endpointString = [...expressions, ...stringInterstitials]
                        .sort((a, b) => a.start - b.start)
                        .map(({ value }) => value)
                        .join('');
                }
                else {
                    endpointString = endpointNode.value;
                }
                const methodProperty = (_e = (_d = optionsNode) === null || _d === void 0 ? void 0 : _d.properties) === null || _e === void 0 ? void 0 : _e.filter((value) => value.type === 'ObjectProperty' && value.key.name === 'method')[0];
                const methodValue = ((_f = methodProperty === null || methodProperty === void 0 ? void 0 : methodProperty.value) === null || _f === void 0 ? void 0 : _f.value) || 'GET';
                return {
                    path: endpointString,
                    method: methodValue,
                    line: endpointNode.loc.start.line,
                    column: endpointNode.loc.start.column
                };
            }
        }
    }
    async addForgeUIHookCallErrors(hookCalls) {
        const FORGE_UI_HOOK_PERMISSIONS = {
            useContentProperty: ['read:confluence-props', 'write:confluence-props'],
            useSpaceProperty: ['read:confluence-props', 'write:confluence-props'],
            useIssueProperty: ['read:jira-work', 'write:jira-work']
        };
        const rules = [];
        hookCalls.forEach((hookCall) => {
            const requiredPermissions = FORGE_UI_HOOK_PERMISSIONS[hookCall.hookName];
            if (requiredPermissions) {
                const getHookRule = (permission) => ({
                    class: cli_shared_1.environmentToOption(this.environment) === DEV ? linter_interface_1.LintClass.Warning : linter_interface_1.LintClass.Error,
                    message: `${permission.includes('confluence') ? 'Confluence' : 'Jira'} UI hook: "${hookCall.hookName}" requires the "${permission}" scope`,
                    reference: 'permission-scope-required',
                    line: hookCall.line,
                    column: hookCall.column,
                    metadata: {
                        missingPermission: permission
                    }
                });
                requiredPermissions.forEach((requiredPermission) => {
                    var _a;
                    if (!((_a = this.manifest.permissions) === null || _a === void 0 ? void 0 : _a.scopes.includes(requiredPermission))) {
                        rules.push(getHookRule(requiredPermission));
                    }
                });
            }
        });
        return rules;
    }
    async addStorageApiCallErrors(apiCalls) {
        var _a, _b;
        const storagePermission = 'storage:app';
        if (!((_b = (_a = this.manifest.permissions) === null || _a === void 0 ? void 0 : _a.scopes) === null || _b === void 0 ? void 0 : _b.includes(storagePermission))) {
            return apiCalls.map((apiCall) => (Object.assign(Object.assign({ class: cli_shared_1.environmentToOption(this.environment) === DEV ? linter_interface_1.LintClass.Warning : linter_interface_1.LintClass.Error, message: `Using the Forge Storage API requires the "${storagePermission}" scope`, reference: 'permission-scope-required' }, apiCall), { metadata: {
                    missingPermission: storagePermission
                } })));
        }
        return [];
    }
    async addProductApiCallErrors(product, apiCalls, pathMap) {
        const rules = [];
        const potentialErrors = new Set();
        apiCalls.forEach(({ path, method, column, line }) => {
            const pathWithoutQuery = path.replace(/\?.+$/, '');
            pathMap.forEach((_, regex) => {
                if (regex.test(pathWithoutQuery)) {
                    potentialErrors.add({ path: pathWithoutQuery, regex, method: method.toLowerCase(), column, line });
                }
            });
        });
        potentialErrors.forEach(({ method, line, column, regex }) => {
            var _a, _b, _c;
            const missingScopes = [];
            if (regex) {
                (_c = (_b = (_a = pathMap.get(regex)) === null || _a === void 0 ? void 0 : _a.methods[method]) === null || _b === void 0 ? void 0 : _b.security) === null || _c === void 0 ? void 0 : _c.forEach((entry) => {
                    if (entry['OAuth2']) {
                        entry['OAuth2'].forEach((permission) => {
                            var _a, _b, _c;
                            if (!this.manifest.permissions || !((_c = (_b = (_a = this.manifest) === null || _a === void 0 ? void 0 : _a.permissions) === null || _b === void 0 ? void 0 : _b.scopes) === null || _c === void 0 ? void 0 : _c.includes(permission)))
                                missingScopes.push(permission);
                        });
                    }
                    if (entry['oAuthDefinitions']) {
                        entry['oAuthDefinitions'].forEach((permission) => {
                            var _a, _b, _c;
                            if (!this.manifest.permissions || !((_c = (_b = (_a = this.manifest) === null || _a === void 0 ? void 0 : _a.permissions) === null || _b === void 0 ? void 0 : _b.scopes) === null || _c === void 0 ? void 0 : _c.includes(permission)))
                                missingScopes.push(permission);
                        });
                    }
                });
                missingScopes.forEach((permission) => {
                    var _a;
                    rules.push({
                        class: cli_shared_1.environmentToOption(this.environment) === DEV ? linter_interface_1.LintClass.Warning : linter_interface_1.LintClass.Error,
                        message: `${product} endpoint: ${method.toUpperCase()} ${(_a = pathMap.get(regex)) === null || _a === void 0 ? void 0 : _a.originalPath} requires "${permission}" scope`,
                        reference: 'permission-scope-required',
                        line,
                        column,
                        metadata: {
                            missingPermission: permission
                        }
                    });
                });
            }
        });
        return rules;
    }
    async batchExecute(inputs) {
        return Promise.all(inputs.map((input) => this.execute(input)));
    }
}
exports.PermissionLinter = PermissionLinter;
PermissionLinter.JIRA_CACHE_KEY = 'permissions-jira-cache-key';
PermissionLinter.CONFLUENCE_CACHE_KEY = 'permissions-confluence-cache-key';
