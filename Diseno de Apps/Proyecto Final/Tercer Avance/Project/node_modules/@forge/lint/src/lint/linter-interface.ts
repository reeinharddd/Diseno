import { ASTParseResult } from '../parse';

import { ConfigFile, Logger } from '@forge/cli-shared';

export enum LintClass {
  Error = 'error',
  Warning = 'warning'
}

export type LintLogger = Pick<Logger, 'info'>;

type LintFixer = (errors: LintResultRule[], warnings: LintResultRule[], state: LintFixState) => Promise<LintFixState>; // make this a union with more signatures as more fixers are implemented

export interface LintFixState {
  errorsFixed: number;
  warningsFixed: number;
  manifest: ConfigFile;
}

export class LintResult {
  public errors: LintResultRule[] = [];
  public warnings: LintResultRule[] = [];

  constructor(public file: string, private fixer?: LintFixer) {}

  public add(rule: LintResultRule): void {
    switch (rule.class) {
      case LintClass.Error:
        this.errors.push(rule);
        break;
      default:
        this.warnings.push(rule);
        break;
    }
  }

  public batchAdd(...rules: LintResultRule[]): void {
    rules.forEach(this.add, this);
  }

  public size(): number {
    return this.errors.length + this.warnings.length;
  }

  public hasFixer(): boolean {
    return !!this.fixer;
  }

  public async runFixer(state: LintFixState): Promise<LintFixState> {
    if (this.fixer) {
      return this.fixer(this.errors, this.warnings, state);
    }
    return state;
  }
}

export interface LintResultRule {
  class: LintClass;
  message: string;
  reference: string;
  line: number;
  column: number;
  metadata?: Record<string, any>;
}

export interface LintInput {
  ast: ASTParseResult | null;
  filepath: string;
}

export interface LinterInterface {
  bootstrap(): Promise<void>;
  batchExecute(asts: LintInput[]): Promise<LintResult[]>;
}
