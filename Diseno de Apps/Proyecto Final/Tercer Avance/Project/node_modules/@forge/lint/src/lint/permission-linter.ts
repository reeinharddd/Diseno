import BaseLinter from './base-linter';
import { LinterInterface, LintResult, LintClass, LintResultRule, LintInput, LintFixState } from './linter-interface';
import { ESTreeSimpleTraverseOptions } from '../parse';
import { ParserTypes } from '../parse/parser-interface';

import { TraverseOptions, NodePath } from '@babel/traverse';
import {
  CallExpression,
  ImportDeclaration,
  ObjectExpression,
  ObjectMethod,
  ObjectProperty,
  SpreadElement,
  StringLiteral,
  TemplateLiteral,
  MemberExpression
} from '@babel/types';
import { CachedConf, Manifest, DEFAULT_ENVIRONMENT_OPTION, environmentToOption } from '@forge/cli-shared';
import { AST_NODE_TYPES as ESTREE_AST_NODE_TYPES, TSESTree } from '@typescript-eslint/typescript-estree';
import fetch from 'node-fetch';

export const ANY_TEXT_REGEX = '\\S*';

const CACHE_KEY = 'PERMISSIONS_LINTER';
const DEV = DEFAULT_ENVIRONMENT_OPTION;
const ONE_HOUR_MS = 1000 * 60 * 60;

interface ProductMethod {
  originalPath: string;
  methods: any;
}

type ProductPathToMethodsMap = Map<RegExp, ProductMethod>;

interface ApiCall {
  line: number;
  column: number;
}

interface ProductApiCall extends ApiCall {
  path: string;
  method: string;
  regex?: RegExp;
}

type StorageApiCall = ApiCall;

interface ForgeUIHookCall extends ApiCall {
  hookName: string;
}

export const findMissingScopes = (errors: LintResultRule[], warnings: LintResultRule[], state?: LintFixState) => {
  const missingPermissions: Set<string> = new Set();

  errors.forEach(({ metadata }) => {
    missingPermissions.add((metadata as Record<string, string>).missingPermission);
    if (state) state.errorsFixed++;
  });

  warnings.forEach(({ metadata }) => {
    missingPermissions.add((metadata as Record<string, string>).missingPermission);
    if (state) state.warningsFixed++;
  });

  return missingPermissions;
};

export const fixMissingPermissions = async (
  errors: LintResultRule[],
  warnings: LintResultRule[],
  state: LintFixState
): Promise<LintFixState> => {
  const missingPermissions = findMissingScopes(errors, warnings, state);

  const currentPermissions: string[] = (await state.manifest.readConfig())?.permissions?.scopes || [];
  currentPermissions.forEach(missingPermissions.add, missingPermissions);

  await state.manifest.writeToConfigFile<string, { scopes: string[] }>('permissions', {
    scopes: [...missingPermissions]
  });

  return state;
};

export class PermissionLinter extends BaseLinter implements LinterInterface {
  static JIRA_CACHE_KEY = 'permissions-jira-cache-key';
  static CONFLUENCE_CACHE_KEY = 'permissions-confluence-cache-key';

  private jira?: ProductPathToMethodsMap;
  private confluence?: ProductPathToMethodsMap;
  private cache?: CachedConf;

  constructor(environment: string, private manifest: Manifest) {
    super(environment);
  }

  public async bootstrap(): Promise<void> {
    this.cache = CachedConf.getCache(CACHE_KEY);
    const [jira, confluence] = await Promise.all([
      this.getProductPaths(
        PermissionLinter.JIRA_CACHE_KEY,
        'https://developer.atlassian.com/cloud/jira/platform/swagger-v3.v3.json'
      ),
      this.getProductPaths(
        PermissionLinter.CONFLUENCE_CACHE_KEY,
        'https://developer.atlassian.com/cloud/confluence/swagger.v3.json'
      )
    ]);

    this.jira = this.processPaths(jira.paths);
    this.confluence = this.processPaths(confluence.paths);
  }

  public async getProductPaths(cacheKey: string, url: string): Promise<{ paths: Record<string, unknown> }> {
    const cached = this.cache?.get<{ paths: Record<string, unknown> }>(cacheKey);
    if (!cached) {
      const response = await fetch(url);
      const jsonBody = await response.json();
      this.cache?.set<{ paths: Record<string, unknown> }>(cacheKey, jsonBody, 12 * ONE_HOUR_MS);
      return jsonBody;
    }
    return cached;
  }

  private processPaths(paths: Record<string, unknown>): ProductPathToMethodsMap {
    const pathMap: Map<RegExp, ProductMethod> = new Map();

    Object.keys(paths).forEach((path: string) => {
      const key = new RegExp(path.replace(/{(?<={)(.*?)(?=})}/g, ANY_TEXT_REGEX) + '$');
      pathMap.set(key, { originalPath: path, methods: paths[path] });
    });

    return pathMap;
  }

  private async execute({ ast, filepath }: LintInput): Promise<LintResult> {
    if (!this.jira || !this.confluence) throw new Error('Bootstrap failed');

    const lintResult = new LintResult(filepath, fixMissingPermissions);
    const jiraApiCalls: ProductApiCall[] = [];
    const confluenceApiCalls: ProductApiCall[] = [];
    const storageApiCalls: StorageApiCall[] = [];
    const forgeUIHookCalls: ForgeUIHookCall[] = [];

    if (ast?.type === ParserTypes.Babel) {
      ast.traverse<TraverseOptions>({
        /**
         * Targets requestJira/Confluence used as a named import from api
         * e.g. import { requestJira } from '@forge/api'; requestJira(<some_path, { ...opts });
         */
        CallExpression: (callExpr: NodePath<CallExpression>) => {
          if (callExpr.node.callee.type === 'Identifier') {
            if (callExpr.node.callee.name.match(/request(Jira|Confluence)/)) {
              const [endpointNode, optionsNode] = callExpr.node.arguments;
              const apiCallProblem = this.checkProductApiCallArgs(
                ast.type,
                endpointNode as TemplateLiteral | StringLiteral,
                optionsNode as ObjectExpression
              );
              if (apiCallProblem) {
                if (callExpr.node.callee.name === 'requestJira') {
                  jiraApiCalls.push(apiCallProblem);
                } else {
                  confluenceApiCalls.push(apiCallProblem);
                }
              }
            }
          }
        },
        /**
         * Targets requestJira/Confluence used as a member expression of api (or api's members)
         * e.g. api.asApp().requestJira(<some_path>, { ...opts })
         * Note the above is mutually exclusive with this case
         */
        MemberExpression: (memberExpr: NodePath<MemberExpression>) => {
          if (memberExpr?.node?.property?.name?.match(/request(Jira|Confluence)/)) {
            // We make the assumption that if a member expression is request(Jira|Confluence) that its parent is a CallExpression (i.e. asApp() or asUser())
            const parentCallExpression = memberExpr.parent as CallExpression;
            const [endpointNode, optionsNode] = parentCallExpression.arguments;
            const apiCall = this.checkProductApiCallArgs(
              ast.type,
              endpointNode as TemplateLiteral | StringLiteral,
              optionsNode as ObjectExpression
            );
            if (apiCall) {
              if (memberExpr.node.property.name === 'requestJira') {
                jiraApiCalls.push(apiCall);
              } else {
                confluenceApiCalls.push(apiCall);
              }
            }
          }
        },

        ImportDeclaration: (importDecl: NodePath<ImportDeclaration>) => {
          importDecl.node.specifiers?.filter((specifier) => {
            if (specifier.type === 'ImportSpecifier' && specifier.local.type === 'Identifier') {
              if (specifier.local.name === 'storage') {
                specifier.loc &&
                  storageApiCalls.push({
                    ...specifier.loc.start
                  });
              } else if (specifier.local.name.match(/^use(Space|Content|Issue)Property/)) {
                specifier.loc &&
                  forgeUIHookCalls.push({
                    hookName: specifier.local.name,
                    ...specifier.loc.start
                  });
              }
            }
          });
        }
      });
    } else {
      ast?.traverse &&
        ast.traverse<ESTreeSimpleTraverseOptions>({
          enter: (node, parent) => {
            switch (node.type) {
              /**
               * Targets requestJira/Confluence used as a named import from api
               * e.g. import { requestJira } from '@forge/api'; requestJira(<some_path, { ...opts });
               */
              case ESTREE_AST_NODE_TYPES.CallExpression:
                if (node.callee.type === 'Identifier' && node.callee.name.match(/request(Jira|Confluence)/)) {
                  const [endpointNode, optionsNode] = node.arguments;
                  const apiCallProblem = this.checkProductApiCallArgs(
                    ast.type,
                    endpointNode as TSESTree.TemplateLiteral | TSESTree.StringLiteral,
                    optionsNode as TSESTree.ObjectExpression
                  );
                  if (apiCallProblem) {
                    if (node.callee.name === 'requestJira') {
                      jiraApiCalls.push(apiCallProblem);
                    } else {
                      confluenceApiCalls.push(apiCallProblem);
                    }
                  }
                }
                break;
              case ESTREE_AST_NODE_TYPES.MemberExpression:
                if (
                  node.property.type === ESTREE_AST_NODE_TYPES.Identifier &&
                  node.property.name.match(/request(Jira|Confluence)/) &&
                  parent?.type === ESTREE_AST_NODE_TYPES.CallExpression
                ) {
                  // We make the assumption that if a member expression is request(Jira|Confluence) that its parent is a CallExpression (i.e. asApp() or asUser())
                  const [endpointNode, optionsNode] = parent.arguments;
                  const apiCall = this.checkProductApiCallArgs(
                    ast.type,
                    endpointNode as TSESTree.TemplateLiteral,
                    optionsNode as TSESTree.ObjectExpression
                  );
                  if (apiCall) {
                    if (node.property.name === 'requestJira') {
                      jiraApiCalls.push(apiCall);
                    } else {
                      confluenceApiCalls.push(apiCall);
                    }
                  }
                } else if (
                  node.property.type === ESTREE_AST_NODE_TYPES.Identifier &&
                  !node.property.name.startsWith('on') &&
                  node.object.type === ESTREE_AST_NODE_TYPES.MemberExpression &&
                  node.object.object.type === ESTREE_AST_NODE_TYPES.Identifier &&
                  node.object.object.name === 'api' &&
                  node.object.property.type === ESTREE_AST_NODE_TYPES.Identifier &&
                  node.object.property.name === 'store'
                ) {
                  storageApiCalls.push({
                    ...node.loc.start
                  });
                }
                break;
              case ESTREE_AST_NODE_TYPES.ImportDeclaration:
                node.specifiers.forEach((specifier) => {
                  if (
                    specifier.type === ESTREE_AST_NODE_TYPES.ImportSpecifier &&
                    specifier.local.type === ESTREE_AST_NODE_TYPES.Identifier
                  ) {
                    if (specifier.local.name === 'store') {
                      storageApiCalls.push({
                        ...specifier.loc.start
                      });
                    } else if (specifier.local.name.match(/^use(Space|Content|Issue)Property/)) {
                      forgeUIHookCalls.push({
                        hookName: specifier.local.name,
                        ...specifier.loc.start
                      });
                    }
                  }
                });
                break;
            }
          }
        });
    }

    lintResult.batchAdd(
      ...(await this.addProductApiCallErrors('Jira', jiraApiCalls, this.jira)),
      ...(await this.addProductApiCallErrors(
        'Confluence',
        PermissionLinter.processConfluenceURLs(confluenceApiCalls),
        this.confluence
      )),
      ...(await this.addStorageApiCallErrors(storageApiCalls)),
      ...(await this.addForgeUIHookCallErrors(forgeUIHookCalls))
    );

    return lintResult;
  }

  /**
   * Necessary to remove /wiki/rest from endpoints specified by users, which is not present in the swagger docs
   */
  static processConfluenceURLs(confluenceApiCalls: ProductApiCall[]): ProductApiCall[] {
    return confluenceApiCalls.map((apiCall) => ({ ...apiCall, path: apiCall.path.replace(/^.*?\/api/, '/api') }));
  }

  private checkProductApiCallArgs(
    parserType: ParserTypes,
    endpointNode: TSESTree.TemplateLiteral | TSESTree.StringLiteral | TemplateLiteral | StringLiteral,
    optionsNode: TSESTree.ObjectExpression | ObjectExpression
  ): ProductApiCall | undefined {
    if (parserType === ParserTypes.ESTree) {
      if (
        endpointNode.loc &&
        [ESTREE_AST_NODE_TYPES.TemplateLiteral, ESTREE_AST_NODE_TYPES.Literal].includes(
          (endpointNode as TSESTree.TemplateLiteral | TSESTree.StringLiteral).type
        )
      ) {
        let endpointString: string;

        if (endpointNode.type === ESTREE_AST_NODE_TYPES.TemplateLiteral) {
          /**
           * We recreate the full template string, replacing expressions, in order to look it up in our path map
           */
          const expressions = (endpointNode as TSESTree.TemplateLiteral).expressions.map((node: any) => ({
            start: node.start,
            value: ANY_TEXT_REGEX
          }));
          const stringInterstitials = (endpointNode as TSESTree.TemplateLiteral).quasis.map((node: any) => ({
            start: node.start,
            value: node.value.cooked
          }));
          endpointString = [...expressions, ...stringInterstitials]
            .sort((a, b) => a.start - b.start)
            .map(({ value }) => value)
            .join('');
        } else {
          const endpointValue = (endpointNode as TSESTree.StringLiteral).value;
          if (typeof endpointValue === 'string') {
            endpointString = endpointValue;
          } else {
            return;
          }
        }

        const methodProperty = (optionsNode as TSESTree.ObjectExpression)?.properties?.filter(
          (value) =>
            value.type === ESTREE_AST_NODE_TYPES.Property && (value.key as TSESTree.Identifier).name === 'method'
        )[0] as TSESTree.Property;
        const methodValue = (methodProperty?.value as TSESTree.StringLiteral)?.value || 'GET';
        return {
          path: endpointString,
          method: methodValue,
          line: endpointNode.loc.start.line,
          column: endpointNode.loc.start.column
        };
      }
    } else {
      if (endpointNode.loc && ['TemplateLiteral', 'StringLiteral'].includes(endpointNode.type)) {
        let endpointString: string;

        if (endpointNode.type === 'TemplateLiteral') {
          /**
           * We recreate the full template string, replacing expressions, in order to look it up in our path map
           */
          const expressions = (endpointNode as TemplateLiteral).expressions.map((node: any) => ({
            start: node.start,
            value: ANY_TEXT_REGEX
          }));
          const stringInterstitials = (endpointNode as TemplateLiteral).quasis.map((node: any) => ({
            start: node.start,
            value: node.value.cooked
          }));
          endpointString = [...expressions, ...stringInterstitials]
            .sort((a, b) => a.start - b.start)
            .map(({ value }) => value)
            .join('');
        } else {
          endpointString = (endpointNode as StringLiteral).value;
        }

        const methodProperty = (optionsNode as ObjectExpression)?.properties?.filter(
          (value: SpreadElement | ObjectMethod | ObjectProperty) =>
            value.type === 'ObjectProperty' && (value as ObjectProperty).key.name === 'method'
        )[0] as ObjectProperty;
        const methodValue = (methodProperty?.value as StringLiteral)?.value || 'GET';
        return {
          path: endpointString,
          method: methodValue,
          line: endpointNode.loc.start.line,
          column: endpointNode.loc.start.column
        };
      }
    }
  }

  private async addForgeUIHookCallErrors(hookCalls: ForgeUIHookCall[]): Promise<LintResultRule[]> {
    const FORGE_UI_HOOK_PERMISSIONS: Record<string, string[]> = {
      useContentProperty: ['read:confluence-props', 'write:confluence-props'],
      useSpaceProperty: ['read:confluence-props', 'write:confluence-props'],
      useIssueProperty: ['read:jira-work', 'write:jira-work']
    };

    const rules: LintResultRule[] = [];
    hookCalls.forEach((hookCall) => {
      const requiredPermissions = FORGE_UI_HOOK_PERMISSIONS[hookCall.hookName];
      if (requiredPermissions) {
        const getHookRule = (permission: string): LintResultRule => ({
          class: environmentToOption(this.environment) === DEV ? LintClass.Warning : LintClass.Error,
          message: `${permission.includes('confluence') ? 'Confluence' : 'Jira'} UI hook: "${
            hookCall.hookName
          }" requires the "${permission}" scope`,
          reference: 'permission-scope-required',
          line: hookCall.line,
          column: hookCall.column,
          metadata: {
            missingPermission: permission
          }
        });
        requiredPermissions.forEach((requiredPermission) => {
          if (!this.manifest.permissions?.scopes.includes(requiredPermission)) {
            rules.push(getHookRule(requiredPermission));
          }
        });
      }
    });
    return rules;
  }

  private async addStorageApiCallErrors(apiCalls: StorageApiCall[]): Promise<LintResultRule[]> {
    const storagePermission = 'storage:app';
    if (!this.manifest.permissions?.scopes?.includes(storagePermission)) {
      return apiCalls.map((apiCall) => ({
        class: environmentToOption(this.environment) === DEV ? LintClass.Warning : LintClass.Error,
        message: `Using the Forge Storage API requires the "${storagePermission}" scope`,
        reference: 'permission-scope-required',
        ...apiCall,
        metadata: {
          missingPermission: storagePermission
        }
      }));
    }
    return [];
  }

  private async addProductApiCallErrors(
    product: string,
    apiCalls: ProductApiCall[],
    pathMap: ProductPathToMethodsMap
  ): Promise<LintResultRule[]> {
    const rules: LintResultRule[] = [];
    const potentialErrors: Set<ProductApiCall> = new Set();

    apiCalls.forEach(({ path, method, column, line }) => {
      const pathWithoutQuery = path.replace(/\?.+$/, '');
      pathMap.forEach((_, regex) => {
        if (regex.test(pathWithoutQuery)) {
          potentialErrors.add({ path: pathWithoutQuery, regex, method: method.toLowerCase(), column, line });
        }
      });
    });

    potentialErrors.forEach(({ method, line, column, regex }) => {
      const missingScopes: string[] = [];

      if (regex) {
        pathMap.get(regex)?.methods[method]?.security?.forEach((entry: any) => {
          if (entry['OAuth2']) {
            entry['OAuth2'].forEach((permission: string) => {
              if (!this.manifest.permissions || !this.manifest?.permissions?.scopes?.includes(permission))
                missingScopes.push(permission);
            });
          }
          if (entry['oAuthDefinitions']) {
            entry['oAuthDefinitions'].forEach((permission: string) => {
              if (!this.manifest.permissions || !this.manifest?.permissions?.scopes?.includes(permission))
                missingScopes.push(permission);
            });
          }
        });

        missingScopes.forEach((permission: string) => {
          rules.push({
            class: environmentToOption(this.environment) === DEV ? LintClass.Warning : LintClass.Error,
            message: `${product} endpoint: ${method.toUpperCase()} ${
              pathMap.get(regex)?.originalPath
            } requires "${permission}" scope`,
            reference: 'permission-scope-required',
            line,
            column,
            metadata: {
              missingPermission: permission
            }
          });
        });
      }
    });

    return rules;
  }

  public async batchExecute(inputs: LintInput[]): Promise<LintResult[]> {
    return Promise.all(inputs.map((input) => this.execute(input)));
  }
}
