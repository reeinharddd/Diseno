import { PermissionLinter, fixMissingPermissions, findMissingScopes } from '../permission-linter';
import { LintClass, LintResultRule } from '../linter-interface';
import { babelParser, ASTParseResult } from '../../parse';

import fs from 'fs';
import { mock } from '@atlassian/xen-test-util';
import { ConfigFile } from '@forge/cli-shared';

const MOCK_CONFLUENCE_SWAGGER = JSON.parse(fs.readFileSync(`${__dirname}/mock-confluence-swagger.json`).toString());

const getPermissionLinter = async (manifest: any): Promise<PermissionLinter> => {
  const permissionLinter = new PermissionLinter('default', manifest);
  permissionLinter.getProductPaths = async (key, url): Promise<any> => {
    return url.includes('confluence') ? MOCK_CONFLUENCE_SWAGGER : { paths: {} };
  };
  await permissionLinter.bootstrap();
  return permissionLinter;
};

describe('permission linter', () => {
  let mockAST: ASTParseResult;
  const mockFile = `const api = { asApp: () => { requestConfluence: (endpoint, opts) => {} } };\nconst response = api.asApp().requestConfluence(\`/wiki/rest/api/content/\${contentId}\`);`;

  const MOCK_HANDLER_NAME = 'testHandler';
  const MOCK_FN_KEY = 'testFnKey';
  const MOCK_FILE_NAME = 'test';
  const VALID_MANIFEST = {
    modules: {
      macro: [
        {
          key: 'testKey',
          function: MOCK_FN_KEY,
          title: 'testTitle'
        }
      ],
      function: [{ key: MOCK_FN_KEY, handler: `${MOCK_FILE_NAME}.${MOCK_HANDLER_NAME}` }]
    }
  };

  beforeAll(async () => {
    mockAST = await babelParser(mockFile);
  });

  it('should warn when needed permission is missing', async () => {
    const permissionLinter = await getPermissionLinter(VALID_MANIFEST);
    permissionLinter.getProductPaths = async (key, url): Promise<any> => {
      return url.includes('confluence') ? MOCK_CONFLUENCE_SWAGGER : { paths: {} };
    };
    const results = await permissionLinter.batchExecute([
      {
        ast: mockAST,
        filepath: MOCK_FILE_NAME
      }
    ]);
    expect(results).toMatchObject([
      {
        file: MOCK_FILE_NAME,
        fixer: expect.anything(),
        errors: [],
        warnings: [
          {
            class: LintClass.Warning,
            message: 'Confluence endpoint: GET /api/content/{id} requires "read:confluence-content.summary" scope',
            reference: 'permission-scope-required'
          }
        ]
      }
    ]);
  });

  it('should not warn when correct permissions are present', async () => {
    const manifestWithPermissions = {
      ...VALID_MANIFEST,
      permissions: { scopes: ['read:confluence-content.summary'] }
    };
    const permissionLinter = await getPermissionLinter(manifestWithPermissions);
    const results = await permissionLinter.batchExecute([
      {
        ast: mockAST,
        filepath: MOCK_FILE_NAME
      }
    ]);
    expect(results).toMatchObject([
      {
        file: MOCK_FILE_NAME,
        fixer: expect.anything(),
        errors: [],
        warnings: []
      }
    ]);
  });

  it('should automatically fix missing permissions', async () => {
    const mockError = {
      class: LintClass.Error,
      message: '',
      reference: 'permission-scope-required',
      line: 1,
      column: 1,
      metadata: {
        missingPermission: 'mock-error-permission'
      }
    };
    const mockWarning = {
      ...mockError,
      class: LintClass.Warning,
      metadata: {
        missingPermission: 'mock-warning-permission'
      }
    };
    const mockConfigFile = mock(ConfigFile);
    const mockLintFixState = {
      errorsFixed: 0,
      warningsFixed: 0,
      manifest: mockConfigFile
    };
    const fixedState = await fixMissingPermissions([mockError], [mockWarning], mockLintFixState);
    expect(mockConfigFile.readConfig).toHaveBeenCalled();
    expect(mockConfigFile.writeToConfigFile).toHaveBeenCalledWith('permissions', {
      scopes: [mockError.metadata.missingPermission, mockWarning.metadata.missingPermission]
    });
    expect(fixedState).toMatchObject({
      errorsFixed: 1,
      warningsFixed: 1,
      manifest: mockConfigFile
    });
  });

  it('should warn when storage permissions are missing for import', async () => {
    const mockFileUsingStorage = `import { storage } from '@forge/api';`;
    const mockASTUsingStorage = await babelParser(mockFileUsingStorage);

    const permissionLinter = await getPermissionLinter(VALID_MANIFEST);
    permissionLinter.getProductPaths = async (key, url): Promise<any> => {
      return url.includes('confluence') ? MOCK_CONFLUENCE_SWAGGER : { paths: {} };
    };
    const results = await permissionLinter.batchExecute([
      {
        ast: mockASTUsingStorage,
        filepath: MOCK_FILE_NAME
      }
    ]);
    expect(results).toMatchObject([
      {
        file: MOCK_FILE_NAME,
        fixer: expect.anything(),
        errors: [],
        warnings: [
          {
            class: LintClass.Warning,
            message: 'Using the Forge Storage API requires the "storage:app" scope',
            reference: 'permission-scope-required'
          }
        ]
      }
    ]);
  });

  it('should warn when fui hook permissions are missing', async () => {
    const mockFileUsingFUIHooks = `import { useSpaceProperty } from '@forge/ui-confluence';`;
    const mockASTUsingFUIHooks = await babelParser(mockFileUsingFUIHooks);

    const permissionLinter = await getPermissionLinter(VALID_MANIFEST);
    permissionLinter.getProductPaths = async (key, url): Promise<any> => {
      return url.includes('confluence') ? MOCK_CONFLUENCE_SWAGGER : { paths: {} };
    };

    const results = await permissionLinter.batchExecute([
      {
        ast: mockASTUsingFUIHooks,
        filepath: MOCK_FILE_NAME
      }
    ]);

    const getExpectedRule = (permission: string): LintResultRule => ({
      class: LintClass.Warning,
      message: `Confluence UI hook: "useSpaceProperty" requires the "${permission}" scope`,
      column: 9,
      line: 1,
      reference: 'permission-scope-required'
    });

    expect(results).toMatchObject([
      {
        file: MOCK_FILE_NAME,
        fixer: expect.anything(),
        errors: [],
        warnings: [getExpectedRule('read:confluence-props'), getExpectedRule('write:confluence-props')]
      }
    ]);
  });

  it('should find missing scopes', () => {
    const rule = (scope: string) =>
      // @ts-ignore
      ({
        metadata: {
          missingPermission: scope
        }
      } as LintResultRule);

    const warnings = [rule('foo'), rule('foo2')];
    const errors = [rule('bar'), rule('bar2')];

    const scopes = findMissingScopes(errors, warnings);
    expect(Array.from(scopes)).toEqual(expect.arrayContaining(['foo', 'foo2', 'bar', 'bar2']));
  });
});
