import { reportLintResults, parseSourceFile, lint } from '../lint';
import { LintLogger, LintResult, LintClass } from '../linter-interface';
import { babelParser, tsParser } from '../../parse';

import { Text, LogColor } from '@forge/cli-shared';
import path from 'path';

describe('lint', () => {
  describe('reportLintResults', () => {
    const mockLogger: LintLogger = {
      info: jest.fn()
    };
    const mockLintResult = new LintResult('mock.file');
    mockLintResult.add({
      class: LintClass.Error,
      message: 'this is a mock error',
      reference: 'mock-error',
      line: 0,
      column: 0
    });
    mockLintResult.add({
      class: LintClass.Warning,
      message: 'this is a mock warning',
      reference: 'mock-warning',
      line: 0,
      column: 0
    });

    it('should correctly report lint results with an error and a warning', () => {
      const {
        line: errorLine,
        column: errorColumn,
        message: errorMessage,
        reference: errorReference
      } = mockLintResult.errors[0];
      const {
        line: warningLine,
        column: warningColumn,
        message: warningMessage,
        reference: warningReference
      } = mockLintResult.warnings[0];
      reportLintResults(mockLogger, [mockLintResult]);
      const expectedMessages = [
        Text.lint.filename(path.resolve(mockLintResult.file)),
        Text.lint.error(errorLine, errorColumn, errorMessage, errorReference),
        Text.lint.warning(warningLine, warningColumn, warningMessage, warningReference),
        Text.lint.summary(1, 1, 0, 0)
      ];
      expectedMessages.forEach((message) => expect(mockLogger.info).toHaveBeenCalledWith(message));
    });

    it('should correctly report an empty lint result', () => {
      reportLintResults(mockLogger, []);
      const expectedMessages = [
        Text.lint.filename(path.resolve(mockLintResult.file)),
        LogColor.trace(Text.lint.noProblems)
      ];
      expectedMessages.forEach((message) => expect(mockLogger.info).toHaveBeenCalledWith(message));
    });
  });

  describe('parseSourceFile', () => {
    it('should correctly call the parser', async () => {
      const mockReadFilePromise = jest.fn();
      const mockParser = jest.fn().mockResolvedValue(null);
      const mockFilePath = 'mock.jsx';
      const result = await parseSourceFile(mockFilePath, mockParser, mockReadFilePromise);
      expect(result).toMatchObject({ ast: null, filepath: mockFilePath });
    });
  });

  describe('lint', () => {
    const mockLinter = {
      bootstrap: jest.fn(),
      batchExecute: jest.fn().mockResolvedValue([])
    };
    const mockParseFunc = jest.fn(async (filepath: string) => ({ ast: null, filepath }));
    const mockManifest = {};
    const mockEnv = 'DUMMY_ENV';

    it("should call each linter's bootstrap and batchExecute", async () => {
      await lint([], mockManifest, mockEnv, mockParseFunc, [mockLinter]);
      expect(mockLinter.bootstrap).toHaveBeenCalled();
      expect(mockLinter.batchExecute).toHaveBeenCalled();
    });

    it('should use the babelParser only on appropriate files', async () => {
      const filesForBabelParsing = ['1.jsx', '1.js'];
      const nonBabelParseFiles = ['1.file', '1.tsx', '1.ts'];
      await lint([...filesForBabelParsing, ...nonBabelParseFiles], mockManifest, mockEnv, mockParseFunc, [mockLinter]);
      filesForBabelParsing.forEach((filename) => expect(mockParseFunc).toHaveBeenCalledWith(filename, babelParser));
      nonBabelParseFiles.forEach((filename) => expect(mockParseFunc).not.toHaveBeenCalledWith(filename, babelParser));
    });

    it('should use the tsParser only on appropriate files', async () => {
      const filesForTSParsing = ['1.tsx', '1.ts'];
      const nonTSParseFiles = ['1.jsx', '1.js', '1.file'];
      await lint([...filesForTSParsing, ...nonTSParseFiles], mockManifest, mockEnv, mockParseFunc, [mockLinter]);
      filesForTSParsing.forEach((filename) => expect(mockParseFunc).toHaveBeenCalledWith(filename, tsParser));
      nonTSParseFiles.forEach((filename) => expect(mockParseFunc).not.toHaveBeenCalledWith(filename, tsParser));
    });

    it("should sort each file's lint results by line number/column", async () => {
      mockLinter.batchExecute.mockResolvedValueOnce([
        {
          errors: [
            {
              line: 1,
              column: 2
            },
            {
              line: 1,
              column: 1
            },
            {
              line: 0,
              column: 1
            }
          ],
          warnings: []
        }
      ]);
      const results = await lint([], mockManifest, mockEnv, mockParseFunc, [mockLinter]);
      expect(results).toMatchObject([
        {
          errors: [
            {
              line: 0,
              column: 1
            },
            {
              line: 1,
              column: 1
            },
            {
              line: 1,
              column: 2
            }
          ],
          warnings: []
        }
      ]);
    });
  });
});
