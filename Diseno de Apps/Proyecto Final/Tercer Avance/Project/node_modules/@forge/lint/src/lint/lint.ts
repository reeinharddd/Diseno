import { LintResult, LintResultRule, LinterInterface, LintInput, LintLogger } from './linter-interface';
import { PermissionLinter } from './permission-linter';
import { babelParser, ASTParseResult, tsParser } from '../parse';

import { flat, LogColor, Manifest, Text, listTSConfigIncludeExclude, FileSystemReader } from '@forge/cli-shared';
import fs from 'fs';
import path from 'path';
import { promisify } from 'util';

export interface LintOptions {
  exclude: string[];
  directory: string;
}

export const reportLintResults = (logger: LintLogger, lintResults: LintResult[]): void => {
  let numErrors = 0,
    numWarnings = 0;
  let noProblemsFound = true;

  if (lintResults.length) {
    lintResults.forEach((lintResult: LintResult) => {
      if (lintResult.size()) {
        noProblemsFound = false;

        numErrors += lintResult.errors.length;
        numWarnings += lintResult.warnings.length;

        logger.info(Text.lint.filename(path.resolve(lintResult.file)));

        lintResult.errors.forEach(({ line, column, message, reference }: LintResultRule) => {
          logger.info(Text.lint.error(line, column, message, reference));
        });

        lintResult.warnings.forEach(({ line, column, message, reference }: LintResultRule) => {
          logger.info(Text.lint.warning(line, column, message, reference));
        });
      }
    });
  }

  if (noProblemsFound) {
    logger.info(LogColor.trace(Text.lint.noProblems));
    logger.info('');
  } else {
    const resultsWithFixers = lintResults.filter((result) => result.hasFixer());
    const numFixableErrors = resultsWithFixers.reduce((count, result) => count + result.errors.length, 0);
    const numFixableWarnings = resultsWithFixers.reduce((count, result) => count + result.warnings.length, 0);
    logger.info(Text.lint.summary(numErrors, numWarnings, numFixableErrors, numFixableWarnings));
    process.exitCode = 1;
  }
};

export const parseSourceFile = async (
  filepath: string,
  parser: (code: string, ...args: any[]) => Promise<ASTParseResult>,
  readFilePromise: typeof fs.readFile.__promisify__ = promisify(fs.readFile)
): Promise<LintInput> => {
  const code = await readFilePromise(filepath, { encoding: 'utf-8' });
  const parseResult = await parser(code, filepath);
  return {
    ast: parseResult,
    filepath
  };
};

export const lint = async (
  filesToLint: string[],
  manifest: Manifest,
  environment: string,
  parseFunction = parseSourceFile,
  linters: LinterInterface[] = [new PermissionLinter(environment, manifest)]
): Promise<LintResult[]> => {
  const { include, exclude } = await listTSConfigIncludeExclude(new FileSystemReader());
  const tsInclude = new Set(include);
  const tsExclude = new Set(exclude);

  const lintInputs: LintInput[] = (
    await Promise.all(
      filesToLint.map(async (filepath: string) => {
        const ext = path.extname(filepath);
        // TODO: add other cases for different parsers
        if (ext.match(/jsx?$/)) {
          return parseFunction(filepath, babelParser);
        } else if (ext.match(/tsx?$/)) {
          const relativeFilePath = './' + filepath;
          const tsFileIncluded = tsInclude.has(relativeFilePath);
          const tsFileExcluded = tsExclude.has(relativeFilePath);
          if ((tsFileIncluded && !tsFileExcluded) || (!tsInclude.size && !tsExclude.size)) {
            return parseFunction(filepath, tsParser);
          }
        }

        return { ast: null, filepath: '' };
      })
    )
  ).filter((result) => !!result?.ast);

  await Promise.all(linters.map((linter) => linter.bootstrap()));
  const results = await Promise.all<LintResult[]>(linters.map((linter) => linter.batchExecute(lintInputs))).then(flat);
  return results.map((result: LintResult) => {
    const comparator = (a: LintResultRule, b: LintResultRule): number =>
      a.line === b.line ? a.column - b.column : a.line - b.line;
    result.errors = result.errors.sort(comparator);
    result.warnings = result.warnings.sort(comparator);
    return result;
  });
};
