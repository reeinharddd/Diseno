Index: lib/Index.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import { Constraint, ConstraintViolation, lengthBetween, pattern, validateField } from './Constraints';\n\n/**\n * InvalidAriError - an error thrown if an invalid Ari is constructed\n */\nexport class InvalidAriError extends Error {\n  readonly ariString: string;\n  readonly message: string;\n\n  /**\n   * Construct an InvalidAriError given an error message\n   *\n   * @param {string} ariString - the ARI that failed to parse\n   * @param {string|undefined} description - The error message\n   */\n  constructor(ariString: string, description?: string) {\n    super(`Invalid ari string: ${ariString}${description ? '. ' + description : ''}`);\n    this.ariString = ariString;\n\n    // Support correct inheritance in ES5\n    Object.setPrototypeOf(this, InvalidAriError.prototype);\n  }\n\n  /**\n   * Construct an InvalidAriError given some constraint violations\n   *\n   * @param {string} ariString - the ARI that failed to parse\n   * @param {ConstraintViolation<Object>[]} violations - The array of constraint errors\n   */\n  static withConstraintViolations(ariString: string, violations: ConstraintViolation<Object>[]): InvalidAriError {\n    return new InvalidAriError(ariString, violations.map((v: Object) => v.toString()).join('\\n'));\n  }\n}\n\nfunction matchesSegment(value1: string | undefined, value2: string | undefined): boolean {\n  if (value1 === value2) {\n    return true;\n  } else if (value1 === undefined) {\n    return true;\n  }\n\n  return false;\n}\n\nexport type AriConstructorType = {\n  readonly resourceOwner: string;\n  readonly cloudId?: string;\n  readonly resourceType?: string;\n  readonly resourceId?: string;\n};\n\n// constraints are based on draft of v2 spec https://hello.atlassian.net/wiki/spaces/ARCH/pages/161909310/Atlassian+Resource+Identifier+Spec+draft-2.0#AtlassianResourceIdentifierSpec(draft-2.0)-Syntax\nconst basicCharConstraint = pattern(/^[a-z][a-z.-]*$/);\nconst resourceOwnerConstraints: Constraint<string>[] = [lengthBetween(3, 255), basicCharConstraint];\nconst resourceTypeConstraints: Constraint<string>[] = [lengthBetween(3, 255), basicCharConstraint];\nconst cloudIdConstraints: Constraint<string>[] = [lengthBetween(36, 255)];\nconst siteResourceType = 'site';\n\nconst resourceIdChars = /[\\w-._~:@]/.source;\nconst resourceIdConstraints = [pattern(new RegExp(`^${resourceIdChars}+(/${resourceIdChars}*)*$`))];\n\n/**\n * ARI - an Atlassian Resource Identifier used within connect to describe installation contexts.\n *\n * an implementation of https://product-fabric.atlassian.net/wiki/display/PRODUCT/Atlassian+Resource+Identifier\n */\nexport interface Ari {\n  readonly resourceOwner: string;\n  readonly cloudId?: string;\n  readonly resourceType?: string;\n  readonly resourceId?: string;\n  toString: () => string;\n  toJSON: () => string;\n  equals: (other: any) => boolean;\n  contains: (other: Ari) => boolean;\n}\n\nexport class ResourceIdentifier implements Ari {\n  readonly resourceOwner: string;\n  readonly resourceType?: string;\n  readonly resourceId?: string;\n  private ariString?: string;\n  private readonly internalCloudId?: string;\n\n  get cloudId(): string | undefined {\n    if (this.resourceType === siteResourceType){\n      return this.internalCloudId ? this.internalCloudId : this.resourceId;\n    }\n    return this.internalCloudId;\n  }\n\n  /**\n   * Create a new Ari\n   *\n   * Only the resourceOwner is a required field, any other field can be omitted.\n   *\n   * @param {string} values.resourceOwner - the owner of this resource (e.g. hipchat, confluence or jira)\n   * @param {string|undefined} values.cloudId - the cloud id for this identifier, defined in AID\n   * @param {string|undefined} values.resourceType - the resource type this Ari is associated with (e.g. conversation in hipchat)\n   * @param {string|undefined} values.resourceId - a resource identifier, if this is specified the associated resourceType *must* be provided.\n   *\n   * @throws {InvalidAriError} if the provided segments fail to pass validation\n   */\n  constructor(values: AriConstructorType) {\n    this.resourceOwner = values.resourceOwner;\n    this.internalCloudId = values.cloudId;\n    this.resourceType = values.resourceType;\n    this.resourceId = values.resourceId;\n    this.validate();\n  }\n\n  /**\n  * Parse a string as an Ari\n  *\n  * @param {string} ariString - the string to parse\n  * @returns {Ari} the parsed ari\n  * @throws {InvalidAriError} if the string could not be correctly parsed as an Ari.\n  */\n  static parse(ariString: string): Ari {\n    if (!ariString) {\n      throw new InvalidAriError(ariString);\n    }\n\n    const match = ariString.match(/^ari:cloud:([^:/]+):([^:/]*):([^:/]*)\\/(.*)$/);\n    if (!match || (match.length !== 5)) {\n      throw new InvalidAriError(ariString);\n    }\n\n    const terms = match.map((a: string) => a && a.length > 0 ? a : undefined);\n    const resourceOwner = terms[1];\n    if (!resourceOwner) {\n      throw new InvalidAriError(ariString);\n    }\n    return new ResourceIdentifier({\n      resourceOwner: resourceOwner,\n      cloudId: terms[2],\n      resourceType: terms[3],\n      resourceId: terms[4]\n    } as any);\n  }\n\n  /**\n   * Converts this Ari to a string.\n   */\n  toString(): string {\n    if (!this.ariString) {\n      const resourceId = this.resourceType === siteResourceType && this.internalCloudId ? this.internalCloudId : (this.resourceId || '');\n      const resourceType = this.resourceType || '';\n      const sanitizedCloudId = this.resourceType === siteResourceType ? '' : this.internalCloudId || '';\n      this.ariString = `ari:cloud:${this.resourceOwner}:${sanitizedCloudId}:${resourceType}/${resourceId}`;\n    }\n    return this.ariString;\n  }\n\n  /**\n   * Converts this object to its json representation\n   */\n  toJSON(): string {\n    return this.toString();\n  }\n\n  /**\n   * Checks if this context is the same as another context\n   *\n   * @param {Ari} other - the other parameter to match with\n   * @returns {boolean} - true if all segments of both Aris are equal, false otherwise\n   */\n  equals(other: any): boolean {\n    return other instanceof ResourceIdentifier\n      && this.resourceOwner === other.resourceOwner\n      && this.cloudId === other.cloudId\n      && this.resourceType === other.resourceType\n      && this.resourceId === other.resourceId;\n  }\n\n  /**\n   * This method checks if the current context contains the other context.\n   *\n   * Note: it does that by transforming a site context  (e.g. `ari:cloud:<resource owner>:site/<cloud id>`)\n   * if required to an \"any\" resource type context (e.g. `ari:cloud:<resource owner>:<cloud id>:/`)\n   *\n   * @param {Ari} other\n   * @returns {boolean}\n   */\n  contains(other: Ari): boolean {\n    const SITE_RESOURCE_TYPE = 'site';\n    if (this.resourceType === SITE_RESOURCE_TYPE && other.resourceType !== SITE_RESOURCE_TYPE) {\n      const { resourceId, resourceOwner } = this;\n      if (!resourceId) {\n        return false;\n      }\n      const resourceIdentifier = new ResourceIdentifier({\n        cloudId: resourceId,\n        resourceOwner\n      });\n      return resourceIdentifier.matches(other);\n    }\n    if (this.resourceType === SITE_RESOURCE_TYPE && other.resourceType === SITE_RESOURCE_TYPE){\n      const thisAri = ResourceIdentifier.parse(this.toString());\n      return new ResourceIdentifier(thisAri).matches(ResourceIdentifier.parse(other.toString()));\n    }\n    return this.matches(other);\n  }\n\n  /**\n   * Checks if this context is the same as or contains the provided context.\n   *\n   * Undefined segments in this ARI are treated as wildcards for matching purposes, but must exactly\n   *  match if they are provided in the `other` Ari - i.e. this method is not commutative.\n   *\n   * e.g.\n   * ```\n   * parse('ari:cloud:hipchat::/').contains(parse('ari:cloud:hipchat:cloudid:conversation/blah')) === true\n   * parse('ari:cloud:hipchat:cloudid:conversation/blah').contains(parse('ari:cloud:hipchat::/')) === false\n   *\n   * @param {Ari} other - the other parameter to match with\n   * @returns {boolean} true if this Ari is the same as the other Ari, or matches the other Ari. False otherwise.\n   */\n  private matches(other: Ari): boolean {\n    return matchesSegment(this.resourceOwner, other.resourceOwner)\n      && matchesSegment(this.cloudId, other.cloudId)\n      && matchesSegment(this.resourceType, other.resourceType)\n      && matchesSegment(this.resourceId, other.resourceId);\n  }\n\n  private validate(): void {\n    const constraintViolations = [\n      validateField('resourceOwner', this.resourceOwner, resourceOwnerConstraints),\n      validateField('resourceType', this.resourceType, resourceTypeConstraints),\n      validateField('resourceId', this.resourceId, resourceIdConstraints),\n      validateField('cloudId', this.cloudId, cloudIdConstraints)\n    ]\n      .filter((v: ConstraintViolation<any> | undefined) => v) as ConstraintViolation<any>[];\n\n    if (constraintViolations.length > 0) {\n      throw InvalidAriError.withConstraintViolations(this.toString(), constraintViolations);\n    }\n\n    if (this.resourceId !== undefined && this.resourceType === undefined) {\n      throw new InvalidAriError(this.toString(), 'The resource type must be specified if the resource id is defined.');\n    }\n  }\n}\n\n/**\n * Parse a string as an Ari\n *\n * @param {string} ariString - the string to parse\n * @returns {Ari} the parsed ari\n * @throws {InvalidAriError} if the string could not be correctly parsed as an Ari.\n */\nexport function parse(ariString: string): Ari {\n  return ResourceIdentifier.parse(ariString);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/Index.ts	(date 1550020354000)
+++ lib/Index.ts	(date 1550024569000)
@@ -73,6 +73,7 @@
   toJSON: () => string;
   equals: (other: any) => boolean;
   contains: (other: Ari) => boolean;
+  readonly upgraded: Ari;
 }
 
 export class ResourceIdentifier implements Ari {
@@ -83,7 +84,7 @@
   private readonly internalCloudId?: string;
 
   get cloudId(): string | undefined {
-    if (this.resourceType === siteResourceType){
+    if (this.resourceType === siteResourceType) {
       return this.internalCloudId ? this.internalCloudId : this.resourceId;
     }
     return this.internalCloudId;
@@ -173,6 +174,39 @@
       && this.resourceId === other.resourceId;
   }
 
+  get upgraded(): ResourceIdentifier {
+    const {resourceId, resourceOwner, cloudId} = this;
+    if (!resourceId) {
+      return new ResourceIdentifier({
+        resourceOwner,
+        resourceType: siteResourceType,
+        resourceId: cloudId,
+      });
+    } else {
+      return this;
+    }
+  }
+
+  private toWildcardFormat(): ResourceIdentifier {
+    const {resourceId, resourceOwner, resourceType, cloudId} = this;
+    if (resourceType === siteResourceType) {
+      return new ResourceIdentifier({
+        resourceOwner,
+        cloudId: resourceId,
+
+      })
+    }
+    if (!resourceId) {
+      return new ResourceIdentifier({
+        resourceOwner,
+        resourceType: siteResourceType,
+        resourceId: cloudId,
+      });
+    } else {
+      return this;
+    }
+  }
+
   /**
    * This method checks if the current context contains the other context.
    *
@@ -183,23 +217,7 @@
    * @returns {boolean}
    */
   contains(other: Ari): boolean {
-    const SITE_RESOURCE_TYPE = 'site';
-    if (this.resourceType === SITE_RESOURCE_TYPE && other.resourceType !== SITE_RESOURCE_TYPE) {
-      const { resourceId, resourceOwner } = this;
-      if (!resourceId) {
-        return false;
-      }
-      const resourceIdentifier = new ResourceIdentifier({
-        cloudId: resourceId,
-        resourceOwner
-      });
-      return resourceIdentifier.matches(other);
-    }
-    if (this.resourceType === SITE_RESOURCE_TYPE && other.resourceType === SITE_RESOURCE_TYPE){
-      const thisAri = ResourceIdentifier.parse(this.toString());
-      return new ResourceIdentifier(thisAri).matches(ResourceIdentifier.parse(other.toString()));
-    }
-    return this.matches(other);
+    return this.upgraded.matches(other.upgraded);
   }
 
   /**
