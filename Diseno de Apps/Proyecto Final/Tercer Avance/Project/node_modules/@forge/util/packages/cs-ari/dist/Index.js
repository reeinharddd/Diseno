"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var Constraints_1 = require("./Constraints");
__export(require("./AppAris"));
/**
 * InvalidAriError - an error thrown if an invalid Ari is constructed
 */
var InvalidAriError = /** @class */ (function (_super) {
    __extends(InvalidAriError, _super);
    /**
     * Construct an InvalidAriError given an error message
     *
     * @param {string} ariString - the ARI that failed to parse
     * @param {string|undefined} description - The error message
     */
    function InvalidAriError(ariString, description) {
        var _this = _super.call(this, "Invalid ari string: " + ariString + (description ? '. ' + description : '')) || this;
        _this.ariString = ariString;
        // Support correct inheritance in ES5
        Object.setPrototypeOf(_this, InvalidAriError.prototype);
        return _this;
    }
    /**
     * Construct an InvalidAriError given some constraint violations
     *
     * @param {string} ariString - the ARI that failed to parse
     * @param {ConstraintViolation<Object>[]} violations - The array of constraint errors
     */
    InvalidAriError.withConstraintViolations = function (ariString, violations) {
        return new InvalidAriError(ariString, violations.map(function (v) { return v.toString(); }).join('\n'));
    };
    return InvalidAriError;
}(Error));
exports.InvalidAriError = InvalidAriError;
function matchesSegment(value1, value2) {
    if (value1 === value2) {
        return true;
    }
    else if (value1 === undefined) {
        return true;
    }
    return false;
}
// constraints are based on draft of v2 spec https://hello.atlassian.net/wiki/spaces/ARCH/pages/161909310/Atlassian+Resource+Identifier+Spec+draft-2.0#AtlassianResourceIdentifierSpec(draft-2.0)-Syntax
var basicCharConstraint = Constraints_1.pattern(/^[a-z][a-z.-]*$/);
var resourceOwnerConstraints = [Constraints_1.lengthBetween(3, 255), basicCharConstraint];
var resourceTypeConstraints = [Constraints_1.lengthBetween(3, 255), basicCharConstraint];
var cloudIdConstraints = [Constraints_1.lengthBetween(36, 255)];
var siteResourceType = 'site';
var resourceIdChars = /[\w-._~:@]/.source;
var resourceIdConstraints = [Constraints_1.pattern(new RegExp("^" + resourceIdChars + "+(/" + resourceIdChars + "*)*(;v=" + resourceIdChars + "*)*$"))];
/**
 * Returns an Ari that is of the latest version of the Ari spec that we support. Any legacy formats
 * (like those for site wide ARIs) are upgraded to their latest form.
 */
function upgrade(values) {
    var resourceId = values.resourceId, resourceOwner = values.resourceOwner, cloudId = values.cloudId;
    // note: The new ARI spec has not defined a format for system wide contexts so we exclude them from upgrade
    if (!resourceId && cloudId) {
        return {
            resourceOwner: resourceOwner,
            resourceType: siteResourceType,
            resourceId: cloudId,
        };
    }
    else {
        return values;
    }
}
var ResourceIdentifier = /** @class */ (function () {
    /**
     * Create a new Ari
     *
     * Only the resourceOwner is a required field, any other field can be omitted.
     * Older format types are converted on creation
     *
     * @param {string} values.resourceOwner - the owner of this resource (e.g. hipchat, confluence or jira)
     * @param {string|undefined} values.cloudId - the cloud id for this identifier, defined in AID
     * @param {string|undefined} values.resourceType - the resource type this Ari is associated with (e.g. conversation in hipchat)
     * @param {string|undefined} values.resourceId - a resource identifier, if this is specified the associated resourceType *must* be provided.
     *
     * @throws {InvalidAriError} if the provided segments fail to pass validation
     */
    function ResourceIdentifier(values) {
        var _a = upgrade(values), resourceId = _a.resourceId, resourceOwner = _a.resourceOwner, resourceType = _a.resourceType, cloudId = _a.cloudId;
        this.resourceOwner = resourceOwner;
        this.internalCloudId = cloudId;
        this.resourceType = resourceType;
        this.resourceId = resourceId;
        this.validate();
    }
    Object.defineProperty(ResourceIdentifier.prototype, "cloudId", {
        get: function () {
            if (this.resourceType === siteResourceType) {
                return this.internalCloudId ? this.internalCloudId : this.resourceId;
            }
            return this.internalCloudId;
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Parse a string as an Ari
    *
    * @param {string} ariString - the string to parse
    * @returns {Ari} the parsed ari
    * @throws {InvalidAriError} if the string could not be correctly parsed as an Ari.
    */
    ResourceIdentifier.parse = function (ariString) {
        if (!ariString) {
            throw new InvalidAriError(ariString);
        }
        var match = ariString.match(/^ari:cloud:([^:/]+):([^:/]*):([^:/]*)\/(.*)$/);
        if (!match || (match.length !== 5)) {
            throw new InvalidAriError(ariString);
        }
        var terms = match.map(function (a) { return a && a.length > 0 ? a : undefined; });
        var resourceOwner = terms[1];
        if (!resourceOwner) {
            throw new InvalidAriError(ariString);
        }
        return new ResourceIdentifier({
            resourceOwner: resourceOwner,
            cloudId: terms[2],
            resourceType: terms[3],
            resourceId: terms[4]
        });
    };
    ResourceIdentifier.parseEncoded = function (encodedAriString) {
        return parse(decodeURIComponent(encodedAriString));
    };
    /**
     * Converts this Ari to a string.
     */
    ResourceIdentifier.prototype.toString = function () {
        if (!this.ariString) {
            var resourceId = this.resourceType === siteResourceType && this.internalCloudId ? this.internalCloudId : (this.resourceId || '');
            var resourceType = this.resourceType || '';
            var sanitizedCloudId = this.resourceType === siteResourceType ? '' : this.internalCloudId || '';
            this.ariString = "ari:cloud:" + this.resourceOwner + ":" + sanitizedCloudId + ":" + resourceType + "/" + resourceId;
        }
        return this.ariString;
    };
    /**
     * Converts this object to its json representation
     */
    ResourceIdentifier.prototype.toJSON = function () {
        return this.toString();
    };
    /**
     * Checks if this context is the same as another context
     *
     * @param {Ari} other - the other parameter to match with
     * @returns {boolean} - true if all segments of both Aris are equal, false otherwise
     */
    ResourceIdentifier.prototype.equals = function (other) {
        return other instanceof ResourceIdentifier
            && this.resourceOwner === other.resourceOwner
            && this.cloudId === other.cloudId
            && this.resourceType === other.resourceType
            && this.resourceId === other.resourceId;
    };
    /**
     * This method checks if the current context contains the other context.
     *
     * Note: it does that by transforming a site context  (e.g. `ari:cloud:<resource owner>:site/<cloud id>`)
     * if required to an "any" resource type context (e.g. `ari:cloud:<resource owner>:<cloud id>:/`)
     *
     * @param {Ari} other
     * @returns {boolean}
     */
    ResourceIdentifier.prototype.contains = function (other) {
        return this.matches(new ResourceIdentifier(other));
    };
    /**
     * Checks if this context is the same as or contains the provided context.
     *
     * Undefined segments in this ARI are treated as wildcards for matching purposes, but must exactly
     *  match if they are provided in the `other` Ari - i.e. this method is not commutative.
     *
     * e.g.
     * ```
     * parse('ari:cloud:hipchat::/').contains(parse('ari:cloud:hipchat:cloudid:conversation/blah')) === true
     * parse('ari:cloud:hipchat:cloudid:conversation/blah').contains(parse('ari:cloud:hipchat::/')) === false
     *
     * @param {Ari} other - the other parameter to match with
     * @returns {boolean} true if this Ari is the same as the other Ari, or matches the other Ari. False otherwise.
     */
    ResourceIdentifier.prototype.matches = function (other) {
        return matchesSegment(this.resourceOwner, other.resourceOwner)
            && matchesSegment(this.cloudId, other.cloudId)
            && ((this.resourceType === siteResourceType && !!other.resourceType) || matchesSegment(this.resourceType, other.resourceType))
            && ((this.resourceType === siteResourceType && !!other.resourceType) || matchesSegment(this.resourceId, other.resourceId));
    };
    ResourceIdentifier.prototype.validateSiteWide = function () {
        var _a = this, resourceType = _a.resourceType, cloudId = _a.cloudId;
        if (resourceType === siteResourceType && !cloudId) {
            return new Constraints_1.GeneralValidationError('site wide ARIs must have a cloudId');
        }
    };
    ResourceIdentifier.prototype.validate = function () {
        var constraintViolations = [
            Constraints_1.validateField(this, 'resourceOwner', resourceOwnerConstraints),
            Constraints_1.validateField(this, 'resourceType', resourceTypeConstraints),
            Constraints_1.validateField(this, 'resourceId', resourceIdConstraints),
            Constraints_1.validateField(this, 'cloudId', cloudIdConstraints),
            this.validateSiteWide()
        ]
            .filter(function (v) { return v; });
        if (constraintViolations.length > 0) {
            throw InvalidAriError.withConstraintViolations(this.toString(), constraintViolations);
        }
        if (this.resourceId !== undefined && this.resourceType === undefined) {
            throw new InvalidAriError(this.toString(), 'The resource type must be specified if the resource id is defined.');
        }
    };
    ResourceIdentifier.prototype.urlEncode = function () {
        return encodeURIComponent(this.toString());
    };
    ResourceIdentifier.prototype.urlDecode = function () {
        return decodeURIComponent(this.toString());
    };
    return ResourceIdentifier;
}());
exports.ResourceIdentifier = ResourceIdentifier;
/**
 * Parse a string as an Ari
 *
 * @param {string} ariString - the string to parse
 * @returns {Ari} the parsed ari
 * @throws {InvalidAriError} if the string could not be correctly parsed as an Ari.
 */
function parse(ariString) {
    return ResourceIdentifier.parse(ariString);
}
exports.parse = parse;
/**
 * Parse a URL encoded string as an Ari
 *
 * @param {string} encodedAriString - the string to parse
 * @returns {Ari} the parsed ari
 * @throws {InvalidAriError} if the string could not be correctly parsed as an Ari.
 */
function parseEncoded(encodedAriString) {
    return ResourceIdentifier.parseEncoded(encodedAriString);
}
exports.parseEncoded = parseEncoded;
//# sourceMappingURL=Index.js.map