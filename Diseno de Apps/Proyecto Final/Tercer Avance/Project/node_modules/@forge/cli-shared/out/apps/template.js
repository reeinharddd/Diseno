"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const fs_extra_1 = require("fs-extra");
const https_1 = require("https");
const ignore_walk_1 = tslib_1.__importDefault(require("ignore-walk"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const path_1 = require("path");
const tmp_1 = tslib_1.__importDefault(require("tmp"));
const ui_1 = require("../ui");
const BITBUCKET_PROJECT = 'XTEM';
class NoTemplateError extends Error {
    constructor(template) {
        super(ui_1.Text.create.error.template.notFound(template));
    }
}
exports.NoTemplateError = NoTemplateError;
class InvalidTemplateArchiveError extends Error {
}
exports.InvalidTemplateArchiveError = InvalidTemplateArchiveError;
class BitbucketTemplateDownloader {
    async download(template, zipFile) {
        return new Promise((resolve, reject) => {
            const zipUrl = this.buildZipUrl(template);
            const fileStream = fs_1.default.createWriteStream(zipFile);
            const downloadRequest = https_1.request(zipUrl, (res) => {
                if (res.statusCode !== 200) {
                    reject(new NoTemplateError(template));
                    return;
                }
                res.pipe(fileStream);
            });
            downloadRequest.end();
            fileStream.on('finish', resolve);
        });
    }
    buildZipUrl(template) {
        return `https://bitbucket.org/atlassian/${template}/get/master.zip`;
    }
}
exports.BitbucketTemplateDownloader = BitbucketTemplateDownloader;
class BitbucketTemplateExtractor {
    constructor(zipAccessor) {
        this.zipAccessor = zipAccessor;
    }
    async extract(zipFile, destDirectory) {
        const extractDirectory = tmp_1.default.dirSync({ prefix: 'template' }).name;
        try {
            await this.zipAccessor.extract(zipFile, extractDirectory);
            await this.moveArchiveFilesToDirectory(extractDirectory, destDirectory);
        }
        finally {
            fs_extra_1.removeSync(extractDirectory);
        }
    }
    async moveArchiveFilesToDirectory(extractDirectory, destDirectory) {
        const archiveChildren = fs_1.default.readdirSync(extractDirectory);
        if (archiveChildren.length !== 1) {
            throw new InvalidTemplateArchiveError(ui_1.Text.create.error.template.unexpectedArchiveFormat);
        }
        const templateRepoDirectory = path_1.resolve(extractDirectory, archiveChildren[0]);
        const templateEntries = await ignore_walk_1.default({
            path: templateRepoDirectory,
            ignoreFiles: ['.forgeignore']
        });
        const filteredEntries = templateEntries.filter((path) => path_1.basename(path) !== '.forgeignore');
        for (const entry of filteredEntries) {
            const entrySourceFullPath = path_1.resolve(templateRepoDirectory, entry);
            const entryDestFullPath = path_1.resolve(destDirectory, entry);
            fs_extra_1.moveSync(entrySourceFullPath, entryDestFullPath);
        }
    }
}
exports.BitbucketTemplateExtractor = BitbucketTemplateExtractor;
class BitbucketTemplater {
    constructor(downloader, extractor, logger) {
        this.downloader = downloader;
        this.extractor = extractor;
        this.logger = logger;
    }
    async downloadAndExtract(template, directory) {
        this.logger.info(ui_1.Text.create.taskTemplate.title);
        const zipFile = tmp_1.default.fileSync({ postfix: '.zip' }).name;
        const destDirectory = path_1.resolve(process.cwd(), directory);
        try {
            fs_extra_1.mkdirpSync(destDirectory);
            this.logger.debug(ui_1.Text.create.taskTemplate.downloading(template));
            await this.downloader.download(template, zipFile);
            this.logger.debug(ui_1.Text.create.taskTemplate.extracting);
            await this.extractor.extract(zipFile, destDirectory);
        }
        catch (err) {
            fs_extra_1.removeSync(destDirectory);
            throw err;
        }
        finally {
            fs_1.default.unlinkSync(zipFile);
        }
    }
    async getAvailableTemplates() {
        const res = await node_fetch_1.default(`https://api.bitbucket.org/2.0/repositories/atlassian?q=project.key=%22${BITBUCKET_PROJECT}%22&sort=name&pagelen=25`);
        const json = await res.json();
        return json.values.map((repo) => repo.name);
    }
}
exports.BitbucketTemplater = BitbucketTemplater;
