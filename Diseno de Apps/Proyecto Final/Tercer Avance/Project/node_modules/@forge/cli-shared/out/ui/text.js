"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const log_symbols_1 = tslib_1.__importDefault(require("./log-symbols"));
const terminal_link_1 = tslib_1.__importDefault(require("terminal-link"));
const log_color_1 = require("./log-color");
const reinstallCmd = chalk_1.default.bold('npm install -g @atlassian/forge-cli@latest');
const ctrlC = 'Press Ctrl+C to cancel.';
const encryptedValue = '****';
const greenTick = `${chalk_1.default.bold(chalk_1.default.green('✔'))}`;
const buildTerminalLink = (text) => terminal_link_1.default(chalk_1.default.bold(text), text, { fallback: () => chalk_1.default.underline.bold(text) });
const fatalError = (message) => chalk_1.default.bold(chalk_1.default.red(message));
const keytarAccessErrorBase = (message) => `Keytar error detected: ${message}`;
const getLintMessage = (line, column, message, level, colourFunction, reference) => `${chalk_1.default.dim(`${line}:${column}`.padEnd(7))} ${colourFunction(level.padEnd(8))} ${message}  ${chalk_1.default.dim(reference)}\n`;
const checkLintTotalPlurals = (numErrors, numWarnings, numFixableErrors, numFixableWarnings) => ({
    pluralCheckedErrors: `${numErrors} ${numErrors === 1 ? 'error' : 'errors'}`,
    pluralCheckedWarnings: `${numWarnings} ${numWarnings === 1 ? 'warning' : 'warnings'}`,
    pluralCheckedTotal: `${numErrors + numWarnings} ${numErrors + numWarnings === 1 ? 'problem' : 'problems'}`,
    pluralCheckedFixableErrors: `${numFixableErrors} ${numFixableErrors === 1 ? 'error' : 'errors'}`,
    pluralCheckedFixableWarnings: `${numFixableWarnings} ${numFixableWarnings === 1 ? 'warning' : 'warnings'}`
});
exports.Text = {
    error: {
        noKeytar: "The Forge CLI couldn't load the library for securely storing your login credentials. " +
            (process.platform !== 'linux'
                ? `Make sure you have libsecret, then install the CLI again with ${reinstallCmd}.`
                : `To fix this, install the CLI again with ${reinstallCmd}.`),
        noTokenInKeytarOrCache: `Not logged in. Run ${chalk_1.default.bold('forge login')} before rerunning this command.`,
        keytarAccessError: {
            other: (message) => keytarAccessErrorBase(message),
            mac: (message) => keytarAccessErrorBase(message) +
                `\nSomething went wrong while accessing Keychain Access. Try locking and unlocking the login keychain.`,
            linux: (message) => keytarAccessErrorBase(message) + `\nSomething went wrong while accessing Secret Service API.`,
            windows: (message) => keytarAccessErrorBase(message) + `\nSomething went wrong while accessing Credentials Vault.`
        },
        outdatedCLIVersion: (installed, latest) => `Warning: Your version of Forge CLI is out of date. We recommend you update for the latest features and bug fixes.` +
            `\nRun ${chalk_1.default.bold(`npm install -g @forge/cli`)} to update from version ${chalk_1.default.bold(installed)} to ${chalk_1.default.bold(latest)}.` +
            `\n`,
        outdatedNodeVersion: (supportedNodeVersion) => fatalError(`Unsupported Node.js version. The CLI requires Node.js ${supportedNodeVersion}, but you're using Node.js ${process.version}.`),
        failedGettingPythonVersion: (err) => fatalError(`Couldn't get the Python version: ${err.message}.`),
        invalidPythonVersion: (version) => fatalError(`Unsupported Python version. The CLI requires Python 2, but you're using Python ${version}.`),
        invalidProduct: 'Invalid product. Rerun the command with a valid product.',
        invalidSite: 'The site you entered is not an Atlassian site. Rerun the command with the URL to an Atlassian site to install the app.',
        invalidTokenInKeytarOrCache: `Your API token is no longer valid. Run ${chalk_1.default.bold('forge login')} to reset your login credentials.`,
        invalidTokenInEnv: (instructionsUrl, emailVar, tokenVar) => 'The API token on your machine is no longer valid. Please:' +
            `\n    1) Follow these instructions to get an API token: ${instructionsUrl}` +
            `\n    2) Set your email and the token to ${emailVar} and ${tokenVar} environment variables.`,
        invalidContainerTokenInEnv: (tokenVar) => 'The container token on your machine is no longer valid. Please:' +
            `\n    1) Run ${chalk_1.default.bold('forge login:ci')} to get a container token.` +
            `\n    2) Set the token to ${tokenVar} environment variable.`,
        promptInputRequired: 'This input is required.',
        noExecutableFile: "Couldn't find the main executable file",
        unhandledRejection: (reason, promise) => `Error at ${promise}, reason: ${reason}`
    },
    installationContext: {
        overviewProduct: 'Select the product your app uses.\n',
        promptProduct: 'Select a product:',
        overviewSite: '\nEnter your site. For example, your-domain.atlassian.net\n',
        promptSite: 'Enter the site URL:'
    },
    upgradeContext: {
        overview: `To upgrade your app to use the latest scopes, select it from the list.\n${ctrlC}`,
        promptInstallation: 'Select the site to upgrade:'
    },
    optionSite: 'site URL (example.atlassian.net)',
    optionProduct: (supportedProducts) => `product (${supportedProducts.join(', ')})`,
    optionVerbose: 'enable verbose mode',
    invalidCmd: (command) => `’${command}’ is not a Forge command.`,
    invalidCmdHelp: `Run ${chalk_1.default.bold('forge --help')} to see the full list of available commands.`,
    extraArguments: (commandName) => `Unexpected argument. See ${chalk_1.default.bold(`forge ${commandName} --help`)} for a list of available arguments.`,
    rerunningWithVerbose: 'Rerunning the command with --verbose may give more details.',
    ctrlC,
    deprecate: (newCommand) => `This command is deprecated. Consider using "${newCommand}" command instead.`,
    graphQL: {
        request: (url, query, variables) => `▶️  GraphQL ${url}\nQuery: ${query}\nVariables: ${variables}`,
        response: (result, requestId) => `◀️  GraphQL\nRequest ID: ${requestId || 'unknown'}\nResult: ${result}`,
        error: 'Server error'
    },
    snapshot: {
        error: (errorCode, errorMessage) => `Error thrown in the snapshot context.\n${errorCode}: ${errorMessage}`
    },
    bundle: {
        detectedChanges: 'Reloading code...',
        errors: (errors) => `Bundling failed: ${errors.join(', ')}`,
        failed: 'Bundling failed.',
        finished: 'Bundling succeeded.',
        warnings: (warnings) => `Bundling warnings: ${warnings.join(', ')}`
    },
    config: {
        missing: `Your app is not registered.`,
        invalid: `Your app details are invalid.`
    },
    login: {
        cmd: 'log in to your Atlassian account',
        optionEmail: 'specify the email to use',
        optionToken: 'specify the API token to use',
        introText: 'Log in to your Atlassian account',
        promptEmail: 'Enter your email:',
        url: (link) => `Next, enter your Atlassian API token. If you don't have a token, visit this URL to create one:\n${buildTerminalLink(link)}`,
        promptToken: 'Enter your Atlassian API token:',
        checking: 'Logging you in...',
        nextStep: `Now try ${chalk_1.default.bold('forge create')} to start a new app.`,
        success: (name) => `Logged in as ${name}.`,
        error: "We couldn't log you in with those credentials. Check your email address and token before rerunning the command."
    },
    logout: {
        cmd: 'log out of your Atlassian account',
        loggedOut: `${greenTick} Logged out.`
    },
    loginci: {
        cmd: 'create a new authentication token for non-interactive environments',
        success: (tokenFieldName, token) => `CI Token ${tokenFieldName}=${token}`
    },
    whoami: {
        cmd: 'display the account information of the logged in user',
        success: {
            containerToken: (ciTokenKey) => `Logged in with CI Token ${ciTokenKey}`,
            personalCredentials: (email, name, accountId) => `Logged in as ${name} (${email})\nAccount ID: ${accountId}`
        },
        error: {
            personalCredentialsEnv: (emailKey, apiTokenKey) => `We couldn't get your Atlassian account information. Check ${emailKey} and ${apiTokenKey} environment variables.`,
            personalCredentialsKeytar: `We couldn't get your Atlassian account information. You may need to run ${chalk_1.default.bold('forge login')} to log in again.`
        }
    },
    create: {
        cmd: {
            desc: 'create an app',
            start: 'Creating app...',
            success: (appName) => `Created ${appName}`,
            successDetails: (directory, validEnvironmentOptions) => `\nYour app is ready to work on, deploy, and install. We created ${validEnvironmentOptions.length} environments you can deploy to: ${validEnvironmentOptions.join(', ')}.\n\nChange to directory ${chalk_1.default.bold(directory)} to see your app files.`
        },
        intro: (givenDirectory) => `Creating an app in directory ${chalk_1.default.bold(givenDirectory)}.\n`,
        introWithCurrentDirectory: (currentDirectory) => `Creating an app in your current directory:\n\n    ${chalk_1.default.bold(currentDirectory)}\n`,
        optionTemplate: 'specify the template to use',
        optionDirectory: 'specify the directory to create (uses the template name by default)',
        overviewAppName: `\nName your app. The app name can include dashes, spaces, and underscores.\n`,
        overviewTemplates: '\nStart with a template. Each template contains the required files to be a valid app.\n',
        waitTemplates: 'Getting template list...',
        promptName: 'Enter a name for your app:',
        promptTemplate: 'Select a template:',
        taskTemplate: {
            title: 'Downloading template',
            downloading: (template) => `Downloading ${template} template project...`,
            extracting: 'Extracting template'
        },
        taskRegister: 'Registering app',
        taskCreateEnvironments: 'Creating environments',
        taskPackages: 'Installing dependencies',
        error: {
            dirtyDirectory: 'Destination directory is not empty',
            app: {
                creation: "App couldn't be created."
            },
            directory: {
                exists: (path) => `The directory ${path} already exists.`
            },
            template: {
                download: (template) => `Failed to download ${template} template.`,
                notFound: (template) => `Template ${template} doesn't exist.`,
                noTemplates: 'There are no templates to choose from.',
                unexpectedArchiveFormat: 'Unexpected template format.'
            },
            packages: {
                installFail: `Failed to install dependencies`
            }
        }
    },
    register: {
        intro: 'Registering the app to you.',
        cmd: {
            desc: "register an app you didn't create so you can run commands for it",
            start: `Registering app...`,
            success: (appName) => `Registered ${appName}`,
            successDetails: (validEnvironmentOptions) => `\nYour app is ready to work on, deploy, and install. We created ${validEnvironmentOptions.length} environments you can deploy to: ${validEnvironmentOptions.join(', ')}.\n\nUse ${chalk_1.default.bold('forge deploy')} to deploy your app to an environment.`
        },
        confirmQuestion: 'Are you sure you want to overwrite the existing app details?',
        error: {
            appExists: 'The app is already registered',
            appDoesntExists: `There’s no app in this directory. Change to a directory that contains an app manifest file before rerunning the command.`,
            directoryDoesntExists: (path) => `The directory ${path} does not exists.`
        }
    },
    env: {
        option: (defaultEnvOption, validEnvironmentOptions) => `specify the environment from options: ${validEnvironmentOptions.join(', ')} (default: ${defaultEnvOption})`,
        invalid: (validEnvironmentOptions) => `Invalid environment specified. Valid environments: ${validEnvironmentOptions.join(', ')}`,
        error: {
            appNotExist: "App doesn't exist",
            envNotExist: "Environment doesn't exist"
        }
    },
    varsSet: {
        cmd: {
            desc: 'set an environment variable',
            start: 'Setting environment variable...',
            success: 'Environment variable set.'
        },
        overview: (environment, environmentToOption) => `Setting the value of a variable in the ${environmentToOption(environment)} environment.`,
        encryptInfo: 'Encrypting a variable means that the value will not be shown in the terminal.',
        promptEncrypt: `Select if you want the value encrypted:`,
        keyInfo: 'Use a new key to create a variable, or use an existing key to override a variable.',
        promptKey: 'Enter the variable key:',
        promptValue: 'Enter the variable value:',
        optionSecret: 'encrypt variable',
        yes: 'Yes',
        no: 'No'
    },
    varsUnset: {
        cmd: {
            desc: 'remove an environment variable',
            start: (environment, environmentToOption) => `Unsetting the variable in the ${environmentToOption(environment)} environment.`,
            success: (key) => `\n${greenTick} ${key} variable removed.`
        }
    },
    varsList: {
        hint: `\nRun ${chalk_1.default.bold('forge variables:list')} to see your environment variables.\n`,
        cmd: 'list the environment variables',
        empty: (environment, environmentToOption) => `There are no variables in the ${environmentToOption(environment)} environment.\n\nUse ${chalk_1.default.bold('forge variables:set')} to create a variable.\n`,
        encryptedValue,
        overview: (environment, environmentToOption) => `Showing variables from the ${environmentToOption(environment)} environment:\n`,
        postfix: `\nNote, the values of encrypted variables are shown as ${encryptedValue}.\n`
    },
    artifact: {
        error: {
            noDeployUrl: "Couldn't find deployment URL",
            noManifestInZip: (manifestFilename) => `Couldn't find ${manifestFilename} file in the zip archive. Add one.`,
            noManifestAtPath: (path) => `We couldn't find the artifact file ${path}.`,
            empty: 'The provided artifact file was empty.',
            invalidYaml: (manifestFilename) => `The ${manifestFilename} file is not a valid YAML. Fix it and try again.`,
            validation: (manifestFilename) => 'Something went wrong while checking for a manifest file. ' +
                `Ensure the provided file is a zip archive with ${manifestFilename} file at the top level.`
        }
    },
    upload: {
        error: {
            notFound: (path) => `Couldn't find the file: ${path}`,
            empty: (path) => `File ${path} appears to be empty.`,
            status: (status, responseBody) => `Upload failed with status ${status} and body:\n${responseBody}`
        }
    },
    deploy: {
        cmd: {
            desc: 'deploy your app to an environment',
            start1: (environment, environmentToOption) => `Deploying your app to the ${environmentToOption(environment)} environment.\n${ctrlC}\n`,
            start2: (appName, environment, environmentToOption) => `Deploying ${appName} to ${environmentToOption(environment)}...`,
            success: 'Deployed\n',
            successDetails: (appName, environment, environmentToOption) => `Deployed ${appName} to the ${environmentToOption(environment)} environment.`
        },
        taskLint: {
            lintError: log_color_1.LogColor.error(`Error: The deploy failed due to errors in the app code. Fix the errors before rerunning forge deploy, or run ${chalk_1.default.bold('forge deploy --no-verify')} to skip the linter.\n`),
            lintWarning: (numWarnings) => {
                const { pluralCheckedTotal } = checkLintTotalPlurals(0, numWarnings, 0, 0);
                return log_color_1.LogColor.warn(`${pluralCheckedTotal} found. Run ${chalk_1.default.bold('forge lint')} to review the warnings.`);
            }
        },
        taskPackage: {
            title: 'Packaging app files',
            archiverWarning: (err) => `Packaging warning: ${err.message}`,
            fileAddedToArchive: (filePath) => `File added to archive: ${filePath}`,
            packageBundledFiles: 'Packaging bundled files',
            packageManifest: (manifestPath) => `Packaging manifest.yml file from ${manifestPath}`,
            archiveCreated: (archivePath) => `Archive created: ${archivePath}`
        },
        taskUpload: {
            title: 'Uploading app',
            uploadingArchive: (uploadUrl) => `Uploading archive to ${uploadUrl}...`
        },
        taskDeploy: {
            serverStepStarted: (name) => name,
            serverStepFailed: 'Deployment failed'
        },
        error: {
            notFound: "Couldn't find app deployment"
        },
        outdatedInstallations: `Warning: We've detected changes that affect your app's permissions. Your app requires an upgrade. \n` +
            `Run ${chalk_1.default.bold('forge install --upgrade')} for your deployment changes to take effect.`
    },
    install: {
        cmd: {
            description: 'install the app on an Atlassian site',
            start: (appName, environment) => `Installing ${appName} on to ${environment}...`,
            end: `${greenTick} Install complete!`
        },
        booleanToScope: (isLatest) => (isLatest ? `Latest` : `Out-of-date`),
        banner: `\nInstalling your app onto an Atlassian site.\n${ctrlC}\n`,
        optionUpgrade: 'Upgrade an existing installation',
        success: {
            banner: (name, environment, environmentToOption, product, site) => `The app ${name} in the ${environmentToOption(environment)} environment is now installed in ${product} on ${buildTerminalLink(site)}`
        },
        error: {
            invalidAtlassianSite: (url) => `URL you entered doesn't belong to Atlassian site: ${url.toString()}`,
            url: (url) => `Site URL is invalid: ${url}`,
            site: (url) => `Site is invalid: ${url}`,
            serverSideInstallationError: (message) => `Installation error: ${message}`
        },
        security: {
            banner: (site) => `\n${chalk_1.default.gray('=== ')}Security questions\n
Apps installed on ${site} must comply with our corporate security guidelines.
 Read the guidelines on the page below before answering the required security questions:
${buildTerminalLink('https://hello.atlassian.net/wiki/x/iIC1Hg')}\n`,
            questions: [
                'Does the app store, process, or transmit any Personal Data?',
                'Does the app acquire, store, or process credit card and/or payment information?',
                'Does the app store or transmit any data beyond the Atlassian cloud (for example, through API calls to external products or services)?',
                'Does the app make administrative changes to Atlassian products or services?'
            ],
            notTrustedApp: {
                warn: (site) => `\nYou answered ${chalk_1.default.bold('yes')} to one or more of the questions. Corporate security needs to review your app before you install it on ${site}.\n`,
                confirmApproval: `Has corporate security approved your app?`,
                corpSecurityHelpdesk: `\nCreate a legal ticket to request an app review here:\n
${buildTerminalLink('https://jira.sec.internal.atlassian.com/servicedesk/customer/portal/8/create/88')}

When corporate security has approved the app, you can proceed with the installation.\n`
            }
        },
        authorization: {
            banner: `\n${chalk_1.default.gray('=== ')}Authorize your app\n`,
            link: (link) => `Follow the prompts at this URL to authorize your app:
${buildTerminalLink(link)}\n`,
            openBrowser: `Press any key to open the URL in your default browser.`
        }
    },
    upgrade: {
        banner: `\nUpgrading your app on the Atlassian site.\n`,
        cmd: {
            start: (appName, environment) => `Upgrading ${appName} in ${environment}...`,
            end: `${greenTick} Upgrade complete!`,
            error: `Upgrade failed`
        },
        success: {
            banner: (name, environment, environmentToOption, product, site) => `The app ${name} in the ${environmentToOption(environment)} environment is now the latest in ${product} on ${buildTerminalLink(site)}.`
        },
        alreadyUpdated: {
            spinner: 'Site is already at the latest version',
            banner: (name, environment, environmentToOption, product, site) => `\nThe app ${name} in the ${environmentToOption(environment)} environment is at the latest in ${product} on ${buildTerminalLink(site)}.`
        },
        error: {
            serverSideInstallationError: (message) => `Upgrade error: ${message}`
        }
    },
    installList: {
        cmd: 'list app installations',
        banner: (appName) => `\nShowing all the current installations of the app ${appName}:`,
        noCloudId: 'Unknown site with no cloud ID',
        noInstallations: `The app is not installed anywhere.\nRun ${chalk_1.default.bold('forge install')} to install your app on an Atlassian site.\n`
    },
    tunnel: {
        cmd: 'start a tunnel to connect your local code with the app running in the development environment',
        optionDebugger: 'enable debugger mode',
        preamble: 'Running your app locally with Docker. The tunnel displays your usage from everywhere the app in the development environment is installed.',
        startingServer: (environment, environmentToOption) => `Starting tunneling for the ${environmentToOption(environment)} environment. ` +
            `Your local app will receive requests from everywhere the app in the ${environmentToOption(environment)} environment is installed.`,
        startedServer: (port, isDebug) => `Listening for requests${isDebug ? ' on local port ' + port : ''}...`,
        startedTunnel: (tunnelUrl) => `Started tunnel at address: ${tunnelUrl}`,
        stoppingTunnel: 'Stopping tunnel...',
        stoppedTunnel: 'Tunnel stopped.',
        snapshotting: 'Snapshotting functions...',
        snapshottingNoLogs: 'No log output.',
        startedInspector: (serverAddress) => `Chrome inspector URL (add "debugger;" statement to your app to pause):\ndevtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=${serverAddress}\n`,
        invoke: (requestId, handler) => `invocation: ${requestId} ${handler}`,
        reloaded: 'App code reloaded.',
        pullDockerProgress: (percentCompleted) => `Checking Docker image... ${percentCompleted}%`,
        pullDockerSuccess: `Your Docker image is up to date.`,
        preBundleTask: (title) => `${log_color_1.LogColor.trace('===')} ${title}`,
        lintFailed: chalk_1.default.red(`${chalk_1.default.bold('Error:')} Linting failed due to errors in the app code.`),
        bundlingHeader: 'Bundling code...',
        bundlingSucceeded: 'App code bundled.',
        error: {
            create: (status, message) => `Couldn't create tunnel, status code: ${status}, message: ${message}`,
            delete: (status, message) => `Couldn't delete tunnel, status code: ${status}, message: ${message}`,
            handler: {
                format: (handler) => `Function handler "${handler}" must be in format <module>.<function>, example: index.run`,
                notFound: (handler) => `Function with handler "${handler}" was not found`
            },
            pullDocker: `Checking Docker image... failed`,
            tunnelPackageMissing: 'To run tunnel without Docker please: npm install -g @forge/tunnel',
            dockerNotInstalled: (dockerDownloadLink) => 'Cannot find Docker. The tunnel command requires Docker to run your app locally. ' +
                `Get Docker at the following URL before rerunning the tunnel command:\n\n${dockerDownloadLink}`,
            dockerOutOfDate: (dockerDownloadLink) => 'The installed version of Docker should be 17.03 or greater. ' +
                `Update Docker at the following URL before rerunning the tunnel command:\n\n${dockerDownloadLink}`,
            dockerDaemonNotRunning: (err) => `Docker is not running. The tunnel command requires Docker to run your app locally. Open Docker before rerunning the tunnel command.`,
            dockerPullFailed: (err) => `Cannot pull the tunnel image.`
        }
    },
    installationId: {
        prompt: "Enter the app's installation ID:",
        errors: {
            invalid: `Invalid installation ID. Run ${chalk_1.default.bold('forge install:list')} to see the installation IDs for the app.`,
            notFound: (installationId) => `No installation found for installation ID: ${installationId}.`
        }
    },
    uninstall: {
        cmd: {
            desc: 'uninstall the app from an Atlassian site',
            start: 'Uninstalling...',
            success: (isMulti) => (isMulti ? 'Uninstalling...\n\n' : 'Uninstalled\n\n')
        },
        interactive: {
            desc: 'Select where to uninstall the app:',
            progressInfo: (appName) => `To uninstall the app ${appName} from a site, select it from the list.\nPress CTRL+C to cancel.`,
            done: `\n${log_symbols_1.default.success} Apps uninstalled`
        },
        info: 'Uninstalling the app by installation ID.',
        done: (product, domain, environment, environmentToOption, isMulti) => `${isMulti ? log_symbols_1.default.info : log_symbols_1.default.success} Uninstalled from the ${environmentToOption(environment)} environment in ${product} on ${buildTerminalLink(domain)}.`,
        failed: (product, domain, environment, environmentToOption) => `Failed to uninstall the app from the ${environmentToOption(environment)} environment in ${product} on ${buildTerminalLink(domain)}. Try rerunning the command, or ask for help if you continue to see this error.`
    },
    webtrigger: {
        cmd: 'get a web trigger URL',
        copy: (url) => `\nCopy your web trigger URL below to start using it:\n\n${buildTerminalLink(url)}`,
        optionFuncKey: 'web trigger key from the manifest',
        overviewFuncKey: `\nGetting the web trigger URL by installation ID.\n\nPress Ctrl+C to cancel.\n`,
        promptFuncKey: 'Select a web trigger:',
        error: {
            funcKey: "The given web trigger key doesn't exist in your manifest.",
            noWebtriggers: "Your manifest file doesn't contain any web triggers. Add a web trigger to the manifest before " +
                'rerunning this command.'
        }
    },
    logs: {
        cmd: 'view app logs',
        optionInvocation: 'view logs for a given invocation ID',
        optionLimit: 'number of invocations to return',
        optionGroup: 'group logs by invocation ID'
    },
    lint: {
        blurb: "The linter checks the app code for known errors. Warnings are problems you should fix, but that won't stop the app code from building.\nPress Ctrl+C to cancel.\n",
        cmd: 'check source files for common errors',
        running: `Running ${chalk_1.default.bold('forge lint...')}`,
        noProblems: 'No problems found.',
        filename: chalk_1.default.underline,
        fixed: (numFixableErrors, numFixableWarnings) => {
            const { pluralCheckedFixableErrors, pluralCheckedFixableWarnings } = checkLintTotalPlurals(0, 0, numFixableErrors, numFixableWarnings);
            return `${greenTick} Fixed ${pluralCheckedFixableErrors} and ${pluralCheckedFixableWarnings}`;
        },
        fixFollowUp: `Run ${chalk_1.default.bold('forge lint')} to review outstanding errors and warnings`,
        error: (line, column, message, reference) => getLintMessage(line, column, message, 'error', log_color_1.LogColor.error, reference),
        summary: (numErrors, numWarnings, numFixableErrors, numFixableWarnings) => {
            const { pluralCheckedErrors, pluralCheckedWarnings, pluralCheckedTotal, pluralCheckedFixableErrors, pluralCheckedFixableWarnings } = checkLintTotalPlurals(numErrors, numWarnings, numFixableErrors, numFixableWarnings);
            const colourFunction = numErrors ? log_color_1.LogColor.error : log_color_1.LogColor.warn;
            const warningCharacter = numErrors ? 'X' : '⚠';
            return colourFunction(`${warningCharacter} ${pluralCheckedTotal} (${pluralCheckedErrors}, ${pluralCheckedWarnings})\n` +
                `  Run ${chalk_1.default.bold('forge lint --fix')} to automatically fix ${pluralCheckedFixableErrors} and ${pluralCheckedFixableWarnings}.\n`);
        },
        warning: (line, column, message, reference) => getLintMessage(line, column, message, 'warning', log_color_1.LogColor.warn, reference)
    },
    customPrompts: {
        table: {
            promptMessage: (message) => `${chalk_1.default.green('?')} ${message}`,
            headerMessage: (message, singleOption) => `${chalk_1.default.bold(message)} ${chalk_1.default.dim(singleOption ? ' (Use the Enter key to select)' : ' (Use the spacebar to select multiple)')}`
        },
        singleSelectionTable: {
            doneHeaderMessage: (message) => `${chalk_1.default.bold(message)}`,
            decorateSelected: (site) => `${chalk_1.default.cyan(site)}`
        }
    }
};
