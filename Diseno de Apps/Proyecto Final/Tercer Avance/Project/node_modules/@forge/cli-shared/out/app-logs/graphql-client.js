"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sanitizeLogLine = (line) => ({
    timestamp: line.timestamp,
    level: line.level || undefined,
    message: line.message || undefined,
    other: line.other
});
class MissingAppLogsError extends Error {
}
exports.MissingAppLogsError = MissingAppLogsError;
class MissingAppLogLinesError extends Error {
}
exports.MissingAppLogLinesError = MissingAppLogLinesError;
class MissingInvocationError extends Error {
}
exports.MissingInvocationError = MissingInvocationError;
class MissingMetadataError extends Error {
}
exports.MissingMetadataError = MissingMetadataError;
class LogsGraphQLClient {
    constructor(graphqlClient) {
        this.graphqlClient = graphqlClient;
    }
    async viewInvocationLogs(details) {
        const result = await this.getInvocationLogs(details);
        if (!result.lines.length) {
            throw new MissingInvocationError();
        }
        return Object.assign(Object.assign({}, this.extractInvocationInfo(result.metadata)), { logs: result.lines.map(sanitizeLogLine) });
    }
    async viewAppLogs(details) {
        const query = `
      query appLogs($appId: ID!, $environmentId: [ID!]!, $limit: Int!, $contextAri: [ID!]) {
        appLogs(
          appId: $appId,
          environmentId: $environmentId,
          last: $limit,
          query: {
            installationContexts: $contextAri
          }
        ) {
          nodes {
            id
            function {
              key
            }
            appVersion
            trigger {
              type
            }
            appLogLines {
              edges {
                node {
                  timestamp
                  level
                  message
                  other
                }
                cursor
              }
              pageInfo {
                hasNextPage
              }
            }
          }
        }
      }
    `;
        const result = await this.graphqlClient.query(query, details);
        if (!result.appLogs || !result.appLogs.nodes) {
            throw new MissingAppLogsError();
        }
        const invocations = [];
        for (const node of result.appLogs.nodes) {
            if (node) {
                const invocation = this.extractInvocationInfo(node);
                if (node.appLogLines != null) {
                    const { cursor, lines } = this.extractLogLines(node.appLogLines);
                    const firstLogs = lines.map(sanitizeLogLine);
                    if (!node.appLogLines.pageInfo.hasNextPage) {
                        invocation.logs = firstLogs;
                    }
                    else {
                        const nextLines = await this.getInvocationLogs({ invocationId: invocation.id, after: cursor });
                        invocation.logs = [...firstLogs, ...nextLines.lines.map(sanitizeLogLine)];
                    }
                }
                invocations.push(invocation);
            }
        }
        return invocations;
    }
    extractInvocationInfo(metadata) {
        return {
            id: metadata.id,
            appVersion: metadata.appVersion,
            function: (metadata.function && metadata.function.key) || undefined,
            trigger: (metadata.trigger && metadata.trigger.type) || undefined,
            logs: []
        };
    }
    extractLogLines(connection) {
        const lines = [];
        let cursor;
        for (const edge of connection.edges || []) {
            if (edge) {
                cursor = edge.cursor;
                lines.push(edge.node);
            }
        }
        return { cursor, lines };
    }
    async getInvocationLogs(filter) {
        const query = `
      query appLogLines($invocationId: ID!, $after: String) {
        appLogLines(
          after: $after,
          invocation: $invocationId
        ) {
          metadata {
            id
            function {
              key
            }
            appVersion
            trigger {
              type
            }
          }
          edges {
            node {
              timestamp
              level
              message
              other
            }
            cursor
          }
          pageInfo {
            hasNextPage
          }
        }
      }
    `;
        const result = await this.graphqlClient.query(query, filter);
        if (!result.appLogLines) {
            throw new MissingAppLogLinesError();
        }
        const { cursor, lines } = this.extractLogLines(result.appLogLines);
        if (result.appLogLines.pageInfo.hasNextPage) {
            const nextLines = await this.getInvocationLogs(Object.assign(Object.assign({}, filter), { after: cursor }));
            lines.push(...nextLines.lines);
        }
        return {
            lines,
            metadata: result.appLogLines.metadata
        };
    }
}
exports.LogsGraphQLClient = LogsGraphQLClient;
