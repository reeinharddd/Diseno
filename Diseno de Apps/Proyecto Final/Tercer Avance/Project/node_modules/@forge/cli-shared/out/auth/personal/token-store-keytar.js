"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Either_1 = require("fp-ts/lib/Either");
const shared_1 = require("../../shared");
const ui_1 = require("../../ui");
const os_1 = require("os");
const abstract_token_store_getter_1 = require("./abstract-token-store-getter");
const token_store_1 = require("./token-store");
const KEYTAR_SERVICE = 'Atlassian';
const KEYTAR_ACCOUNT = 'Ecosystem';
function getKeytar(ui) {
    try {
        return require('keytar');
    }
    catch (_a) {
        const error = new Error(ui_1.Text.error.noKeytar);
        return shared_1.exitOnError(ui)(error);
    }
}
exports.getKeytar = getKeytar;
exports.hasKeytar = () => {
    try {
        require('keytar');
        return true;
    }
    catch (_a) {
        return false;
    }
};
class KeytarPersonalApiCredentialsStore extends abstract_token_store_getter_1.AbstractPersonalApiCredentialsGetter {
    constructor(graphqlGateway, keytarProvider) {
        super(graphqlGateway);
        this.graphqlGateway = graphqlGateway;
        this.keytarProvider = keytarProvider;
    }
    async getCredentialsImpl() {
        let stringifiedPersonalApiCredentials;
        try {
            stringifiedPersonalApiCredentials = await this.keytarProvider().getPassword(KEYTAR_SERVICE, KEYTAR_ACCOUNT);
        }
        catch (e) {
            this.wrapKeytarError(e);
        }
        if (!stringifiedPersonalApiCredentials) {
            throw new token_store_1.NoTokenInStoreError();
        }
        let personalApiCredentials;
        try {
            personalApiCredentials = JSON.parse(stringifiedPersonalApiCredentials);
        }
        catch (_a) {
            throw new token_store_1.NoTokenInStoreError();
        }
        const decodeResult = token_store_1.personalApiCredentialsValidatedShape.decode(personalApiCredentials);
        if (Either_1.isLeft(decodeResult)) {
            throw new token_store_1.NoTokenInStoreError();
        }
        return decodeResult.right;
    }
    getInstructionsWhenInvalidImpl() {
        return ui_1.Text.error.invalidTokenInKeytarOrCache;
    }
    setCredentials(credentials) {
        return this.keytarProvider()
            .setPassword(KEYTAR_SERVICE, KEYTAR_ACCOUNT, JSON.stringify(credentials))
            .catch((e) => this.wrapKeytarError(e));
    }
    deleteCredentials() {
        return this.keytarProvider()
            .deletePassword(KEYTAR_SERVICE, KEYTAR_ACCOUNT)
            .catch((e) => this.wrapKeytarError(e));
    }
    wrapKeytarError(e) {
        let error;
        const currentPlatform = os_1.platform();
        switch (currentPlatform) {
            case 'darwin':
                error = ui_1.Text.error.keytarAccessError.mac(e.message);
                break;
            case 'linux':
                error = ui_1.Text.error.keytarAccessError.linux(e.message);
                break;
            case 'win32':
                error = ui_1.Text.error.keytarAccessError.windows(e.message);
                break;
            default:
                error = ui_1.Text.error.keytarAccessError.other(e.message);
        }
        throw new Error(error);
    }
}
exports.KeytarPersonalApiCredentialsStore = KeytarPersonalApiCredentialsStore;
