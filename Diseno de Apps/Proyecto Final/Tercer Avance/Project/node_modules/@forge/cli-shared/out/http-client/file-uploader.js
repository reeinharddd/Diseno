"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const ui_1 = require("../ui");
class CannotUploadFileError extends Error {
}
exports.CannotUploadFileError = CannotUploadFileError;
class UploadFileNotFoundError extends Error {
}
exports.UploadFileNotFoundError = UploadFileNotFoundError;
class UploadFileEmptyError extends Error {
}
exports.UploadFileEmptyError = UploadFileEmptyError;
const validateFileContents = (filePath, fileContents) => {
    if (!fileContents) {
        throw new UploadFileNotFoundError(ui_1.Text.upload.error.notFound(filePath));
    }
    if (!fileContents.length) {
        throw new UploadFileEmptyError(ui_1.Text.upload.error.empty(filePath));
    }
    return fileContents;
};
const checkResponse = async (response) => {
    if (!response.ok) {
        throw new CannotUploadFileError(ui_1.Text.upload.error.status(response.status, await response.text()));
    }
};
class HttpFileUploader {
    constructor(fileSystem) {
        this.fileSystem = fileSystem;
    }
    async uploadFromPath(url, filePath) {
        const fileContents = this.fileSystem.readBinaryFile(filePath);
        const validFileContents = validateFileContents(filePath, fileContents);
        const response = await node_fetch_1.default(url, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/zip',
                'Content-Length': validFileContents.length.toString()
            },
            body: validFileContents
        });
        await checkResponse(response);
    }
}
exports.HttpFileUploader = HttpFileUploader;
