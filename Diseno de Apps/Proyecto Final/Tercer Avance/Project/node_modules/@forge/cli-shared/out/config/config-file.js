"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const yaml_1 = tslib_1.__importStar(require("yaml"));
const util_1 = require("yaml/util");
const path_1 = require("path");
const ui_1 = require("../ui");
const _1 = require("./");
const case_1 = tslib_1.__importDefault(require("case"));
class ConfigFile {
    constructor(fileReader, fileWriter) {
        this.fileReader = fileReader;
        this.fileWriter = fileWriter;
    }
    manifestExist(directory) {
        const manifestPath = directory === undefined ? _1.manifestFilename : path_1.join(directory, _1.manifestFilename);
        return this.fileReader.fileExists(manifestPath);
    }
    async getAppHandlers() {
        var _a;
        const config = await this.readConfig();
        const functions = (_a = config.modules) === null || _a === void 0 ? void 0 : _a[_1.FUNCTIONS_KEY];
        if (functions === undefined) {
            return ['index'];
        }
        return functions.map((funcs) => funcs.handler.split('.')[0]);
    }
    async readConfig() {
        const manifestFileContents = this.fileReader.readFile(_1.manifestFilename);
        if (!manifestFileContents) {
            return {};
        }
        try {
            yaml_1.default.scalarOptions.null.nullStr = '';
            return yaml_1.parse(manifestFileContents);
        }
        catch (_a) {
            throw new ui_1.ValidationError(ui_1.Text.artifact.error.invalidYaml(_1.manifestFilename));
        }
    }
    async readConfigToDocument() {
        const manifestFileContents = this.fileReader.readFile(_1.manifestFilename);
        if (manifestFileContents) {
            try {
                return yaml_1.parseDocument(manifestFileContents);
            }
            catch (_a) {
                throw new ui_1.ValidationError(ui_1.Text.artifact.error.invalidYaml(_1.manifestFilename));
            }
        }
    }
    async snapshotsEnabled() {
        var _a, _b;
        const config = await this.readConfig();
        const entry = (_b = (_a = config.app) === null || _a === void 0 ? void 0 : _a.runtime) === null || _b === void 0 ? void 0 : _b.snapshots;
        return entry || entry === undefined ? true : false;
    }
    makeManifestUnique(modules, appName) {
        const actualModules = {};
        for (const [moduleKey, moduleArray] of Object.entries(modules)) {
            actualModules[moduleKey] = moduleArray === null || moduleArray === void 0 ? void 0 : moduleArray.map((module) => {
                if (moduleKey !== 'function' && !moduleKey.startsWith(case_1.default.kebab(appName))) {
                    module['key'] = case_1.default.kebab([appName, module.key].join(' '));
                    if ('title' in module) {
                        module['title'] = appName;
                    }
                    if ('name' in module) {
                        module['name'] = appName;
                    }
                }
                return module;
            });
        }
        return actualModules;
    }
    async writeToConfigFile(configKey, config) {
        const manifestFileContents = this.fileReader.readFile(_1.manifestFilename);
        const currentConfigDoc = yaml_1.parseDocument(manifestFileContents || '');
        const modules = currentConfigDoc.get('modules');
        if (modules && modules.type === util_1.Type.MAP && config.name) {
            const modulesObject = modules.toJSON();
            const modulesWithUniqueName = this.makeManifestUnique(modulesObject, config.name);
            currentConfigDoc.set('modules', modulesWithUniqueName);
        }
        Object.keys(config).forEach((key) => {
            if (config[key] === undefined) {
                delete config[key];
            }
        });
        currentConfigDoc.set(configKey, config);
        this.fileWriter.writeStringToFile(currentConfigDoc.toString(), _1.manifestFilename);
    }
}
exports.ConfigFile = ConfigFile;
