"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const ora_1 = tslib_1.__importDefault(require("ora"));
const log_color_1 = require("./log-color");
const log_symbols_1 = tslib_1.__importDefault(require("./log-symbols"));
const logger_1 = require("./logger");
const text_1 = require("./text");
const runtime_log_1 = require("./runtime-log");
const multiple_table_prompt_1 = require("./multiple-table-prompt");
const single_table_prompt_1 = require("./single-table-prompt");
var ProgressLogType;
(function (ProgressLogType) {
    ProgressLogType[ProgressLogType["startText"] = 0] = "startText";
    ProgressLogType[ProgressLogType["successText"] = 1] = "successText";
    ProgressLogType[ProgressLogType["other"] = 2] = "other";
})(ProgressLogType || (ProgressLogType = {}));
class CommandLineUI {
    constructor(verbose, spinner, logger) {
        this.verbose = verbose;
        this.insideProgress = false;
        this.addedProgressPadding = false;
        this.spinner = spinner || ora_1.default({ discardStdin: false });
        this.logger = logger || console;
        this.registerCustomUIElements();
    }
    get traceEnabled() {
        return this.verbose();
    }
    get debugEnabled() {
        return this.verbose();
    }
    async displayProgress(progress, startText, successText) {
        try {
            this.insideProgress = true;
            this.addedProgressPadding = false;
            if (!this.debugEnabled) {
                this.spinner.spinner = 'dots';
                this.spinner.start();
            }
            this.log(startText, ProgressLogType.startText);
            const result = await progress();
            const progressResult = typeof successText === 'function' ? successText(result) : successText;
            const isSuccessful = typeof progressResult === 'string' || progressResult.successful;
            if (isSuccessful) {
                this.logSuccess(progressResult.message || progressResult);
            }
            else {
                this.logError(progressResult.message);
            }
            this.stopProgressSpinner(isSuccessful);
            return result;
        }
        catch (err) {
            this.stopProgressSpinner(false);
            throw err;
        }
        finally {
            this.insideProgress = false;
        }
    }
    async displayTemporaryMessage(progress, waitText) {
        try {
            this.insideProgress = true;
            this.addedProgressPadding = false;
            if (this.debugEnabled) {
                this.log(waitText, ProgressLogType.startText);
            }
            else {
                this.spinner.spinner = { interval: 9999, frames: [''] };
                this.spinner.prefixText = waitText;
                this.spinner.start();
            }
            const result = await progress();
            this.stopWaitSpinner(true);
            return result;
        }
        catch (err) {
            this.stopWaitSpinner(false);
            throw err;
        }
        finally {
            this.insideProgress = false;
        }
    }
    trace(message) {
        if (!this.traceEnabled) {
            return;
        }
        const color = log_color_1.LogColor.trace(message);
        const msg = this.insideProgress ? '  ' + color : color;
        this.log(msg);
    }
    debug(message) {
        if (!this.debugEnabled) {
            return;
        }
        const color = log_color_1.LogColor.debug(message);
        const msg = this.insideProgress ? '  ' + color : color;
        this.log(msg);
    }
    info(message) {
        const msg = this.insideProgress ? log_symbols_1.default.info + ' ' + message : message;
        this.log(msg);
    }
    warn(message) {
        const color = log_color_1.LogColor.warn(message);
        const msg = this.insideProgress ? log_symbols_1.default.warning + ' ' + color : color;
        this.log(msg);
    }
    error(error, { pad = true } = {}) {
        const message = logger_1.errorMessage(error);
        const color = log_color_1.LogColor.error(message);
        let msg = '\n' + log_color_1.LogColor.errorPrefix + color + '\n';
        if (!pad) {
            msg = msg.trim();
        }
        this.log(msg);
        if (error.stack) {
            this.debug(error.stack);
        }
    }
    snapshotLog(message, level = 'INFO') {
        const logMessage = runtime_log_1.formatRuntimeLogLevel(level) + ' ' + runtime_log_1.formatRuntimeLogArgs([message]);
        this.log(logMessage);
    }
    emptyLine() {
        this.log('');
    }
    async confirm(message) {
        const { choice } = await inquirer_1.default.prompt([
            {
                type: 'confirm',
                name: 'choice',
                message,
                default: false
            }
        ]);
        return choice;
    }
    promptForText(message, defaultValue) {
        return this.promptForString(message, false, defaultValue);
    }
    promptForSecret(message) {
        return this.promptForString(message, true);
    }
    async promptForList(message, choices) {
        const { choice } = await inquirer_1.default.prompt([
            {
                type: 'list',
                name: 'choice',
                message,
                choices
            }
        ]);
        return choice;
    }
    async promptForTable(message, infoMessage, columns, choices) {
        const { choice } = await inquirer_1.default.prompt([
            {
                type: 'multiple-choice-table',
                name: 'choice',
                message,
                infoMessage,
                columns,
                choices
            }
        ]);
        return choice;
    }
    async promptForSingleChoiceTable(message, infoMessage, columns, choices) {
        const { choice } = await inquirer_1.default.prompt([
            {
                type: 'single-choice-table',
                name: 'choice',
                message,
                infoMessage,
                columns,
                choices
            }
        ]);
        return choice;
    }
    log(message, progressLogType = ProgressLogType.other) {
        let msg = message;
        if (this.insideProgress) {
            const addPadding = (progressLogType === ProgressLogType.other && !this.addedProgressPadding) ||
                (progressLogType === ProgressLogType.successText && this.addedProgressPadding);
            if (addPadding) {
                msg = '\n' + msg;
                this.addedProgressPadding = true;
            }
        }
        if (this.spinner.isSpinning) {
            this.spinner.text += msg + '\n';
        }
        else {
            this.logger.log(msg);
        }
    }
    logSuccess(successText) {
        if (this.addedProgressPadding) {
            this.log(log_symbols_1.default.success + ' ' + successText, ProgressLogType.successText);
        }
        else {
            this.replaceStartTextOnSuccess(successText);
        }
    }
    logError(errorText) {
        if (this.spinner.isSpinning) {
            this.spinner.text = errorText;
        }
        else {
            this.log(log_symbols_1.default.error + ' ' + errorText, ProgressLogType.other);
        }
    }
    stopProgressSpinner(success) {
        if (!this.spinner.isSpinning) {
            return;
        }
        if (this.spinner.text.endsWith('\n')) {
            this.spinner.text = this.spinner.text.substring(0, this.spinner.text.length - 1);
        }
        const symbol = success ? log_symbols_1.default.success : log_symbols_1.default.error;
        this.spinner.stopAndPersist({ symbol });
    }
    replaceStartTextOnSuccess(successText) {
        if (this.spinner.isSpinning) {
            this.spinner.text = successText;
        }
        else {
            this.log(log_symbols_1.default.success + ' ' + successText, ProgressLogType.successText);
        }
    }
    stopWaitSpinner(success) {
        if (!this.spinner.isSpinning) {
            return;
        }
        if (success) {
            this.spinner.prefixText = '';
            this.spinner.stop();
        }
        else {
            this.spinner.stopAndPersist();
        }
    }
    async promptForString(message, secret, defaultValue) {
        const { text } = await inquirer_1.default.prompt([
            {
                type: secret ? 'password' : 'input',
                name: 'text',
                message,
                default: defaultValue,
                validate: (input) => (input.length === 0 ? text_1.Text.error.promptInputRequired : true)
            }
        ]);
        return text;
    }
    registerCustomUIElements() {
        inquirer_1.default.registerPrompt('multiple-choice-table', multiple_table_prompt_1.MultipleChoiceTablePrompt);
        inquirer_1.default.registerPrompt('single-choice-table', single_table_prompt_1.SingleChoiceTablePrompt);
    }
}
exports.CommandLineUI = CommandLineUI;
