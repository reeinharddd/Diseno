"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const memfs_1 = require("memfs");
const path_1 = require("path");
const webpack_1 = tslib_1.__importDefault(require("webpack"));
const stub_plugin_1 = require("./stub-plugin");
const text_1 = require("./text");
const cli_shared_1 = require("@forge/cli-shared");
const lint_1 = require("@forge/lint");
const readMemoryFileSync = (filePath) => {
    return memfs_1.fs.readFileSync(filePath, { encoding: 'utf8' });
};
const outputMemoryFileSystem = {
    join: path_1.join,
    mkdir: memfs_1.fs.mkdir,
    mkdirp: memfs_1.fs.mkdirp,
    rmdir: memfs_1.fs.rmdir,
    unlink: memfs_1.fs.unlink,
    writeFile: memfs_1.fs.writeFile
};
const resolveModulePath = (moduleName) => {
    return require.resolve(moduleName);
};
const handleCallback = (err, stats) => {
    if (err) {
        throw err;
    }
    const info = stats.toJson();
    if (stats.hasErrors()) {
        const isTSError = info.errors.every((e) => e.includes('[tsl]'));
        if (isTSError) {
            const formattedErrors = info.errors.map((error) => {
                return error.replace(/\.?.+.tsx?(?!\([0-9]\,[0-9]\))$/gm, '');
            });
            throw new Error(text_1.Text.typescriptError(formattedErrors));
        }
        else {
            throw new Error(text_1.Text.genericBundlingError(info.errors));
        }
    }
    if (stats.hasWarnings()) {
        const warnings = text_1.Text.warnings(info.warnings);
        console.warn(chalk_1.default.magenta(warnings));
    }
    return stats;
};
exports.getDevToolConfig = (config) => {
    if (!config.isWatchMode) {
        return 'source-map';
    }
    return config.isDebugMode ? 'cheap-module-eval-source-map' : 'cheap-source-map';
};
const getCustomModulesAliases = () => {
    return {
        'browserify-cipher': resolveModulePath('browserify-cipher/browser.js'),
        'browserify-sign/algos': resolveModulePath('browserify-sign/algos.js'),
        'browserify-sign': resolveModulePath('browserify-sign/browser/index.js'),
        'create-ecdh': resolveModulePath('create-ecdh/browser.js'),
        'create-hash/md5': resolveModulePath('create-hash/md5.js'),
        'create-hash': resolveModulePath('create-hash/browser.js'),
        'create-hmac': resolveModulePath('create-hmac/browser.js'),
        'diffie-hellman': resolveModulePath('diffie-hellman/browser.js'),
        pbkdf2: resolveModulePath('pbkdf2/browser.js'),
        process: resolveModulePath('process/browser.js'),
        'public-encrypt': resolveModulePath('public-encrypt/browser.js'),
        randombytes: resolveModulePath('randombytes/browser.js'),
        randomfill: resolveModulePath('randomfill/browser.js'),
        fs: resolveModulePath('memfs'),
        http: resolveModulePath('./http'),
        https: resolveModulePath('./http'),
        path: resolveModulePath('path-browserify'),
        querystring: resolveModulePath('querystring-browser'),
        stream: resolveModulePath('readable-stream'),
        'supports-color': resolveModulePath('supports-color/index.js')
    };
};
const getBuildConfig = (entrypoints, config) => {
    if (!require.main) {
        throw new Error(text_1.Text.noExecutableFile);
    }
    const resolvedEntryPoints = {};
    for (const entrypoint of entrypoints) {
        resolvedEntryPoints[entrypoint.name] = path_1.resolve(entrypoint.path);
    }
    return {
        entry: Object.assign({}, resolvedEntryPoints),
        mode: 'production',
        target: 'webworker',
        optimization: {
            minimize: false
        },
        devtool: exports.getDevToolConfig(config),
        output: {
            libraryTarget: 'commonjs',
            globalObject: 'this',
            filename: '[name].js',
            path: '/'
        },
        module: {
            rules: [
                {
                    test: /(readable-stream|pbkdf2|util)\//,
                    resolve: {
                        aliasFields: ['browser']
                    }
                },
                {
                    test: /axios\//,
                    resolve: {
                        aliasFields: []
                    }
                },
                {
                    test: /\.jsx?$/,
                    exclude: /node_modules/,
                    use: [
                        {
                            loader: 'babel-loader',
                            options: {
                                presets: [
                                    [
                                        resolveModulePath('@babel/preset-typescript'),
                                        {
                                            isTSX: true,
                                            jsxPragma: 'ForgeUI',
                                            allExtensions: true
                                        }
                                    ]
                                ],
                                plugins: [
                                    [
                                        resolveModulePath('@babel/plugin-transform-react-jsx'),
                                        {
                                            pragma: 'ForgeUI.createElement'
                                        }
                                    ],
                                    resolveModulePath('@forge/babel-plugin-transform-ui'),
                                    resolveModulePath('@babel/plugin-proposal-numeric-separator'),
                                    resolveModulePath('@babel/plugin-proposal-class-properties')
                                ],
                                cacheDirectory: true
                            }
                        }
                    ]
                },
                {
                    test: /\.tsx?$/,
                    use: [
                        {
                            loader: 'ts-loader',
                            options: {
                                compilerOptions: {
                                    jsx: 'react',
                                    jsxFactory: 'ForgeUI.createElement'
                                }
                            }
                        }
                    ]
                }
            ]
        },
        node: {
            __dirname: true,
            process: false
        },
        performance: false,
        resolve: {
            mainFields: ['main', 'module'],
            alias: getCustomModulesAliases(),
            extensions: ['.ts', '.tsx', '.js', '.jsx', '.json']
        },
        resolveLoader: {
            modules: require.resolve.paths('babel-loader') || undefined
        },
        plugins: [
            new webpack_1.default.IgnorePlugin(/^encoding$/, /node-fetch/),
            new webpack_1.default.ProvidePlugin({
                path: resolveModulePath('path-browserify'),
                querystring: resolveModulePath('querystring-browser'),
                stream: resolveModulePath('readable-stream'),
                TextDecoder: [resolveModulePath('text-encoder-lite'), 'TextDecoderLite'],
                TextEncoder: [resolveModulePath('text-encoder-lite'), 'TextEncoderLite'],
                URL: [resolveModulePath('whatwg-url'), 'URL'],
                URLSearchParams: [resolveModulePath('whatwg-url'), 'URLSearchParams']
            }),
            new stub_plugin_1.StubPlugin({
                modules: [
                    'async_hooks',
                    'child_process',
                    'cluster',
                    'constants',
                    'dgram',
                    'dns',
                    'domain',
                    'http2',
                    'module',
                    'net',
                    'perf_hooks',
                    'readline',
                    'repl',
                    'sys',
                    'tls',
                    'trace_events',
                    'tty',
                    'v8',
                    'vm',
                    'worker_threads'
                ],
                placeholder: 'requestedModule',
                stub: path_1.resolve(__dirname, 'unsupported')
            })
        ]
    };
};
const getCompiler = (endpoints, configBuilder) => {
    const config = getBuildConfig(endpoints, configBuilder);
    const compiler = webpack_1.default(config);
    compiler.outputFileSystem = outputMemoryFileSystem;
    return compiler;
};
const getNodeModuleNames = (stats) => {
    const { modules } = stats.toJson({ modules: true });
    if (modules) {
        const filteredModuleNames = new Set();
        modules.forEach(({ name }) => {
            const parts = name.match(/^\.\/node_modules\/([^/]+)\/([^/]+)/);
            if (parts) {
                const module = parts[1][0] === '@' ? `${parts[1]}/${parts[2]}` : parts[1];
                filteredModuleNames.add(module);
            }
            else if (name.includes('unsupported.js')) {
                filteredModuleNames.add(name.slice(name.indexOf('?')));
            }
        });
        return Array.from(filteredModuleNames);
    }
};
class Monitor {
    constructor(watcher) {
        this.watcher = watcher;
    }
    stop() {
        this.watcher.close(() => null);
    }
}
exports.bundle = (endpoints) => {
    const compiler = getCompiler(endpoints, { isWatchMode: false });
    return new Promise((resolve, reject) => {
        compiler.run((err, stats) => {
            try {
                handleCallback(err, stats);
                const output = {}, sourceMap = {};
                endpoints.forEach(({ name }) => {
                    output[name] = readMemoryFileSync(`/${name}.js`);
                    sourceMap[name] = readMemoryFileSync(`/${name}.js.map`);
                });
                resolve({
                    output,
                    sourceMap,
                    metadata: {
                        modules: getNodeModuleNames(stats)
                    }
                });
            }
            catch (err) {
                reject(err);
            }
        });
    });
};
const runLinter = async (logger = { info: console.log }, fileSystemReader = new cli_shared_1.FileSystemReader(), fileSystemWriter = new cli_shared_1.FileSystemWriter()) => {
    logger.info(`\n${cli_shared_1.Text.tunnel.preBundleTask(cli_shared_1.Text.lint.running)}`);
    const configFile = new cli_shared_1.ConfigFile(fileSystemReader, fileSystemWriter);
    const filesToLint = await fileSystemReader.recursiveReadDir('./', [
        ...(await cli_shared_1.listGitIgnoreFiles(fileSystemReader)),
        '.git',
        'node_modules'
    ]);
    try {
        const lintResults = await lint_1.lint(filesToLint, await configFile.readConfig(), 'development');
        if (lintResults.some((result) => result.size())) {
            logger.info('');
            lint_1.reportLintResults(logger, lintResults);
        }
        else {
            logger.info(cli_shared_1.LogColor.trace(cli_shared_1.Text.lint.noProblems) + '\n');
        }
    }
    catch (error) {
        logger.info(cli_shared_1.Text.tunnel.lintFailed + '\n');
    }
};
exports.watch = (entryPoints, debugMode, callback, watchRun) => {
    const compiler = getCompiler(entryPoints, { isWatchMode: true, isDebugMode: debugMode });
    if (typeof watchRun === 'function') {
        compiler.hooks.watchRun.tapAsync('watchRun', (compiler, callback) => {
            watchRun(compiler, runLinter, callback);
        });
    }
    const watcher = compiler.watch({ poll: 1000 }, (err, stats) => {
        try {
            handleCallback(err, stats);
            const output = {}, sourceMap = {};
            entryPoints.forEach(({ name }) => {
                output[name] = readMemoryFileSync(`/${name}.js`);
                try {
                    sourceMap[name] = readMemoryFileSync(`/${name}.js.map`);
                }
                catch (e) {
                }
            });
            callback(null, {
                output,
                sourceMap
            });
        }
        catch (err) {
            callback(err);
        }
    });
    return new Monitor(watcher);
};
