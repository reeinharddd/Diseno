"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
const url_1 = require("url");
const api_1 = require("@forge/api");
class Response extends readable_stream_1.Readable {
    constructor(content, response) {
        super();
        this.statusCode = response.status;
        this.statusMessage = response.statusText;
        this.headers = {};
        this._read = () => { };
        this.push(Buffer.from(content));
        this.push(null);
    }
}
const isString = (options) => typeof options === 'string';
const isURL = (options) => typeof options === 'object' && options.constructor.name === 'URL';
class Request extends readable_stream_1.Writable {
    constructor(options, callback) {
        super();
        this.reqBody = [];
        this.chainableOptions = {
            headers: {}
        };
        if (callback) {
            this.on('response', callback);
        }
        this.on('finish', this.fetch.bind(this, options));
    }
    setHeader(name, value) {
        this.chainableOptions.headers[name] = value;
        return this;
    }
    setTimeout(value, callback) {
        this.chainableOptions.timeout = value;
        if (callback) {
            this.on('timeout', callback);
        }
        return this;
    }
    fetch(options) {
        const { url, init } = Request.convertToForgeFetchArgs(options, this.chainableOptions);
        if (init.method !== 'GET') {
            init.body = Buffer.concat(this.reqBody);
        }
        api_1.fetch(url, init)
            .then(async (response) => {
            const content = await response.arrayBuffer();
            const transformedAPIResponse = new Response(content, response);
            this.emit('response', transformedAPIResponse);
        })
            .catch((err) => {
            if (err.message.startsWith('network timeout')) {
                this.emit('timeout');
            }
            else {
                this.emit('error', err);
            }
        });
    }
    _write(chunk, encoding, callback) {
        try {
            if (Buffer.isEncoding(encoding)) {
                this.reqBody.push(Buffer.from(chunk, encoding));
            }
            else if (Buffer.isBuffer(chunk)) {
                this.reqBody.push(chunk);
            }
            else {
                this.reqBody.push(Buffer.from(chunk));
            }
            callback();
        }
        catch (err) {
            callback(err);
        }
    }
    static formatUrl(options) {
        const reqUrlBuilder = options;
        reqUrlBuilder.protocol = options.protocol || 'https:';
        if (reqUrlBuilder.path) {
            const { path: originalPath, pathname: originalPathname } = reqUrlBuilder;
            if (reqUrlBuilder.query === undefined) {
                const pathMatch = originalPath === null || originalPath === void 0 ? void 0 : originalPath.match(/(^.*)\?(.*$)/);
                const pathnameMatch = originalPathname === null || originalPathname === void 0 ? void 0 : originalPathname.match(/(^.*)\?(.*$)/);
                if (pathMatch) {
                    const [, pathname, query] = pathMatch;
                    reqUrlBuilder.pathname = pathname;
                    reqUrlBuilder.query = query;
                    reqUrlBuilder.search = `?${query}`;
                }
                else if (pathnameMatch) {
                    const [, pathname, query] = pathnameMatch;
                    reqUrlBuilder.path = reqUrlBuilder.pathname;
                    reqUrlBuilder.pathname = pathname;
                    reqUrlBuilder.query = query;
                    reqUrlBuilder.search = `?${query}`;
                }
                else {
                    reqUrlBuilder.pathname = reqUrlBuilder.path;
                }
            }
        }
        return url_1.format(reqUrlBuilder);
    }
    static convertToForgeFetchArgs(options, chainableOptions) {
        if (isString(options)) {
            return { url: options, init: chainableOptions };
        }
        else if (isURL(options)) {
            return { url: options.toString(), init: chainableOptions };
        }
        else {
            try {
                const reqOpts = {};
                if (options.headers) {
                    reqOpts.headers = {};
                    for (const header in options.headers) {
                        const headerValue = options.headers[header];
                        if (headerValue) {
                            reqOpts.headers[header] = headerValue.toString();
                        }
                    }
                }
                if (options.timeout)
                    reqOpts.timeout = options.timeout;
                reqOpts.method = options.method || 'GET';
                const url = Request.formatUrl(options);
                return { url, init: Object.assign(Object.assign({}, chainableOptions), reqOpts) };
            }
            catch (err) {
                console.error('Unable to make request with unrecognised URL options:', options);
                throw err;
            }
        }
    }
}
exports.Request = Request;
